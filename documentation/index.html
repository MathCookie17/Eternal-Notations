<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" href="documentation.css">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <body>
        <div id="header_logo_div">
            <img id="header_logo_img" src="../eternal_notations_images/eternal_notations header logo.png" style="text-align: center;width:20em;height: auto">
        </div>
        <p>This is the documentation page for Eternal Notations, a JavaScript library used in conjunction with
            <a href="https://github.com/Patashu/break_eternity.js">break_eternity.js</a> to abbreviate very large
            numbers in various notations. The source code is on <a href="https://github.com/MathCookie17/Eternal_Notations">GitHub</a>,
            and you can test out the "preset" notations <a href="../index.html">here</a>.
            <br>
            The boxes below can be clicked to open and close their contents, and likewise for any boxes inside. It is recommended
            you read at least Part 0 before jumping into the rest of the manual. Part 1 is the most important for immediate use of
            the library, Part 2 is the most important if you want a deeper understanding.
        </p>

        <div class="chapter" style="background-color:#8f009c;border:5px solid #d300e7;color:#f480ff;">
            <h2 class="part_title">Part 0: Introduction</h2>
            <p class="start_hide">
                You may already be familiar with
                <a href="https://github.com/antimatter-dimensions/notations">AD Notations</a>, a notations library for
                <a href="https://github.com/Patashu/break_infinity.js/">break_infinity.js</a>, and if you are, then
                Eternal Notations is basically a sequel to AD Notations which works with
                <a href="https://github.com/Patashu/break_eternity.js">break_eternity.js</a> instead of break_infinity.js.
                This library exports a single object, EternalNotations, which contains all of the presets, notations, and
                methods in the library.
            </p>
            <p class="start_hide">
                <b>There are two ways to use this library.</b> If you're looking for something like AD Notations, i.e. a
                bunch of notations that are easy to quickly add to your incremental game, then you'll want to use the
                <b>Presets</b>, described in Part 1. If you want a set of notations with parameters that let you customize
                them to your heart's content, potentially creating new notations out of those already there,
                then you'll want to use the <b>Notations</b>, described in Part 2. Eternal Notations also provides a few
                extra functions, most of which are used on break_eternity Decimals; these are described in Part 3.
            </p>
            <p class="start_hide">
                Like in AD Notations, the main method for a preset or a notation is format(value), which takes a
                DecimalSource (something that can be converted to a Decimal: a number, string, or Decimal) as Parameter
                and writes that value in that notation. Examples:
            </p>
            <div class="code inline_block_display start_hide">
                new EternalNotations.ScientificNotation().format(1e100);<br>
                EternalNotations.Presets.Standard.format("ee50");
            </div>
            <p class="start_hide">
                Unlike AD Notations, the format method does not have parameters for decimal places - those are covered by
                the notation parameters, for reasons that will become apparent in Part 2 - it just has the value
                parameter. Also unlike AD Notations, Eternal Notations typically doesn't distinguish between numbers above 1,000
                and numbers below 1,000 - the notations apply to all. Notations in Eternal Notations cover a wider range of numbers
                than they did in AD Notations, including numbers smaller than 1 (which are ignored by most notations in AD Notations).
            </p>
        </div>

        <div class="chapter" style="background-color:#004394;border:5px solid #0f7bff;color:#4b9cff;">
            <h2 class="part_title">Part 1: Presets</h2>
            <p class="start_hide">
                To use Eternal Notations in the same way you'd use AD Notations, you'll want to use two objects provided within
                Eternal Notations: <code>EternalNotations.Presets</code> and <code>EternalNotations.HTMLPresets</code>.
                These two objects contain all of the <b>presets</b>, which are pre-made, ready-to-use notations. For example,
                to use the Logarithm notation preset, use <code>EternalNotations.Presets.Logarithm</code>. Note that this does
                not use the <code>new</code> operator, as the members of Presets and HTMLPresets already exist. Presets and
                HTMLPresets contain the same notations (with one exception); use Presets when you're outputting to plain text,
                using HTMLPresets when you're outputting to innerHTML. These two objects can be modified, but I'd advise against
                it unless you really know what you're doing (you definitely need to understand Part 2 of this documentation
                in order to be ready to modify the presets objects).
                <br>
                There are currently 124 presets.
                The following is a list of all of them, with what they do written in brackets next to them
                (the ones written in <span class="param_function">yellow</span> are functions that take one parameter):
            </p>
            <ul class="start_hide param_list" id="preset_list">
                <li>
                    Default [This notation basically just cleans up the number without really changing it much.
                    Starts unabbreviated, then scientific, then hyperscientific. Unabbreviated numbers are written with
                    4 significant figures or integer precision, whichever is more precise. Other notations tend to fall back
                    on Default for whatever mantissa is left over once they've done their stuff.]
                </li>
                <li>Scientific [writes numbers in scientific notation]</li>
                <li>Engineering [a variant of scientific notation where the exponent is always a multiple of 3]</li>
                <li>Logarithm [base-10 logarithm]</li>
                <li>
                    Hyperscientific [like scientific notation, but the exponent is a tetrational exponent instead:
                    xFy means 10^10^10^...x with y 10's]
                </li>
                <li>
                    PowerTower [The way <a href="http://www.mrob.com/pub/comp/hypercalc/hypercalc-javascript.html">HyperCalc</a>
                    writes large numbers; basically Hyperscientific, but the mantissa ranges between 10 and 1e10 instead of between 1 and 10.]
                </li>
                <li>SuperLogarithm [base-10 super-logarithm, which is like a regular logarithm but for tetration instead of exponentiation].</li>
                <li>PentaScientific [like Hyperscientific, but for pentation instead of tetration]</li>
                <li>PentaLogarithm [like Super Logarithm, but for pentation instead of tetration]</li>
                <li>NaturalLogarithm [base e logarithm]</li>
                <li>NaturalSuperLogarithm [base e super-logarithm]</li>
                <li>NaturalPentaLogarithm [base e penta-logarithm]</li>
                <li class="param_function">LogarithmBase(base) [Parameter is a DecimalSource; uses the logarithm of that base]</li>
                <li class="param_function">SuperLogarithmBase(base) [Parameter is a DecimalSource; uses the super-logarithm of that base]</li>
                <li class="param_function">PentaLogarithmBase(base) [Parameter is a DecimalSource; uses the penta-logarithm of that base]</li>
                <li>Binary [Base 2]</li>
                <li>Ternary [Base 3]</li>
                <li>Quaternary [Base 4]</li>
                <li>Seximal [Base 6]</li>
                <li>Octal [Base 8]</li>
                <li>Duodecimal [Base 12, using A and B as the added digits]</li>
                <li>DozenalXE [Base 12, using X and E as the added digits]</li>
                <li>Dozenal23 [Base 12, using &#x218A; and &#x218B; as the added digits]</li>
                <li>Hexadecimal [Base 16]</li>
                <li class="param_function">
                    AlternateBase(base) [Parameter is a number, which must be an integer between 2 and 64. Uses that base.
                    Digits up to base 64 are 0 to 9, A to Z, a to z, +, /.
                    $ is the scientific notation character and # is the hyperscientific notation character.]
                </li>
                <li>Balanced Ternary [Base 3, but with digits for -1, 0, and 1 instead of 0, 1, and 2. Uses + for 1 and - for -1.</li>
                <li>Bijective Decimal [Base 10, but with a digit for 10 but no digit for 0. Uses A as the digit for 10.]</li>
                <li>Standard [uses k for thousand, M for million, B for billion, and so on. Prefixes chosen by MathCookie.]</li>
                <li>ADStandard [uses K for thousand, M for million, B for billion, and so on. Prefixes chosen by Antimatter Dimensions.]</li>
                <li>AarexStandard [uses k for thousand, M for million, B for billion, and so on. Prefixes chosen by Aarex Tiaokhiao.]</li>
                <li>LongScale [uses k for thousand, M for million, B for billion, and so on, but using the long scale instead of the short scale. Prefixes chosen by MathCookie.]</li>
                <li>ADLongScale [uses K for thousand, M for million, B for billion, and so on, but using the long scale instead of the short scale. Prefixes chosen by Antimatter Dimensions.]</li>
                <li>AarexLongScale [uses k for thousand, M for million, B for billion, and so on, but using the long scale instead of the short scale. Prefixes chosen by Aarex Tiaokhiao.]</li>
                <li>MixedScientific [uses Standard for numbers below 1e66, Scientific for numbers above 1e66]</li>
                <li>ADMixedScientific [uses ADStandard for numbers below 1e33, Scientific for numbers above 1e33]</li>
                <li>AarexMixedScientific [uses AarexStandard for numbers below 1e36, Scientific for numbers above 1e36]</li>
                <li>MixedScientificLongScale [uses LongScale for numbers below 1e126, Scientific for numbers above 1e126]</li>
                <li>ADMixedScientificLongScale [uses ADLongScale for numbers below 1e60, Scientific for numbers above 1e60]</li>
                <li>AarexMixedScientificLongScale [uses AarexLongScale for numbers below 1e66, Scientific for numbers above 1e66]</li>
                <li>Letters [each power of 1,000 gets a letter: 1,000 is a, 1e6 is b, 1e9 is c, and so on. After z is aa, then ab, and so on. Uppercase letters are used to iterate the amount of lowercase letters recursively.]</li>
                <li>Alphabet [like letters, but using uppercase letters as regular letters and with a zero letter (~), so the letters operate in base 53 instead of bijective base 26. Uses | to separate the recursive tiers.]</li>
                <li>GreekLetters [Letters, but with the 24 letters of the Greek alphabet instead of the 26 letters of the Latin alphabet]</li>
                <li>GreekAlphabet [Letters, but with the 48 total letters of the Greek alphabet instead of the 52 total letters of the Latin alphabet]</li>
                <li>ADGreekLetters [The Greek Letters notation seen in AD Notations, which is GreekAlphabet without a zero letter]</li>
                <li>Emoji [Letters, but each letter is replaced with an emoji]</li>
                <li>EmojiAlphabet [Alphabet, but each letter is replaced with an emoji]</li>
                <li>XYZ [Each X multiplies by 10, each Y turns n into 10<sup>n</sup>, and each Z turns n into 10&#8593;&#8593;n]</li>
                <li>ElementLetters [Letters, but using powers of 118 instead of powers of 1,000 and using the periodic table's element symbols as the letters]</li>
                <li>RomanNumerals [Uses Roman numerals. Large numbers are expressed as multiples, powers, etc. of M&#x305;.</li>
                <li>ADRoman [Uses Roman numerals. Large numbers are expressed in scientific notation with a base of 4,000,000.]</li>
                <li>Septecoman [A variant of Roman numerals that's based on 7s and 17s instead of 5s and 10s]</li>
                <li>SI [Uses the SI prefixes (kilo, mega, giga, etc.). Combines other prefixes with Q and then uses powers/tetrations of Q for larger numbers.]</li>
                <li>SIWritten [Like SI, but the names of the prefixes are written out in full instead of just using their letters]</li>
                <li>BinarySI [Uses the binary SI prefixes (kibi, mebi, gibi, etc.)]</li>
                <li>BinarySIWritten [Like BinarySI, but the names of the prefixes are written out in full instead of just using their letters]</li>
                <li>CombinedD [Uses Standard-style names like M, B, and T, but uses SI-style progression after decillions]</li>
                <li>HyperSI [Uses a made-up set of SI-like prefixes for tetra-powers of 10]</li>
                <li>HyperSIWritten [Like HyperSI, but the names of the prefixes are written out in full instead of just using their letters]</li>
                <li>SandcastleBuilder [Uses the alternate SI prefixes used in <a href="https://castle.chirpingmustard.com/castle.html">Sandcastle Builder</a>]</li>
                <li>SandcastleBuilderWritten [Like SandcastleBuilder, but the names of the prefixes are written out in full instead of just using their letters]</li>
                <li>FractionLoose [Approximates the number as a fraction with a proportional precision of 1e-3]</li>
                <li>FractionMedium [Approximates the number as a fraction with a proportional precision of 1e-6]</li>
                <li>FractionPrecise [Approximates the number as a fraction with a proportional precision of 1e-10]</li>
                <li>MixedNumberLoose [Approximates the number as a mixed number with a proportional precision of 1e-3]</li>
                <li>MixedNumberMedium [Approximates the number as a mixed number with a proportional precision of 1e-6]</li>
                <li>MixedNumberPrecise [Approximates the number as a mixed number with a proportional precision of 1e-10]</li>
                <li>LetterDigits [Like Letters, but there's no mantissa, as the lowercase letters represent the number itself instead of representing a power of 1,000]</li>
                <li>AlphabetDigits [Like Alphabet, but there's no mantissa, as the letters represent the number itself instead of representing a power of 1,000]</li>
                <li>Myriad [Uses <a href="https://en.wikipedia.org/wiki/-yllion">Donald Knuth's -yllion system</a>. Prefixes chosen by MathCookie.]</li>
                <li>ADMyriad [Uses Donald Knuth's -yllion system. Prefixes chosen by Antimatter Dimensions.]</li>
                <li>AarexMyriad [Uses Donald Knuth's -yllion system. Prefixes chosen by Aarex Tiaokhiao.]</li>
                <li>DoubleBinaryNames [Uses the written form of the number naming system devised in Part 6 of <a href="https://www.youtube.com/watch?v=rDDaEVcwIJM">the best way to count</a>]</li>
                <li>DoubleBinaryPrefixes [Uses the symbols from the number naming system in "the best way to count" as SI-like prefixes to make it easier to understand]</li>
                <li>Hypersplit [Writes numbers similarly to <a href="https://naruyoko.github.io/OmegaNum.js/index.html">OmegaNum.js</a>, but with an exponent term between the mantissa and the tetration term]</li>
                <li>HypersplitBase3 [Like Hypersplit, but using 3 as the exponentiation/tetration/pentation base instead of 10]</li>
                <li>Hyper-E [Sbiis Saibian's <a href="https://sites.google.com/site/largenumbers/home/4-3/4-3-1-foray">Hyper-E Notation</a>]</li>
                <li>Infinity [base 2^1024 logarithm]</li>
                <li>Eternity [Takes the base-2^1024 logarithm of the base-10 super-logarithm, so that the resulting number only reaches 1 at break_eternity's limit]</li>
                <li>Brackets [An intentionally confusing notation that uses base-6 logarithms and parentheses, brackets, and braces]</li>
                <li class="param_function">
                    SimplifiedWritten(base) [Parameter is a number, which must be an integer between 2 and 60. Uses the first two
                    letters of the number name for each digit. Scientific notation exponents go in parentheses, hyperscientific exponents
                    in brackets, penta-scientific exponents in braces. The parameter decides what base is being used; digits for 10
                    and above use <a href="https://numerals.fandom.com/wiki/De_Vlieger_Argam">Argam numeral</a> names.]
                </li>
                <li>Dots [Uses Unicode's Braille dot patterns to make a base-254 system, with &#x28FF; reserved as a separator for scientific/hyperscientific]</li>
                <li>Hearts [Uses colored heart emoji to implement resistor color codes]</li>
                <li>Dominoes [Uses double-6 dominoes to make a base-28 number system]</li>
                <li class="param_function">
                    NumericDominoes(highest) [Parameter is a number, which must be a positive integer.
                    Uses the same rules as Dominoes notation; the parameter controls the highest amount of pips on one side of the domino.
                    Dominoes are written in the form [x | y].]
                </li>
                <li class="param_function">
                    ColoredDominoes(highest) [Parameter is a number, which must be a positive integer.
                    Uses the same rules as Dominoes notation; the parameter controls the highest amount of pips on one side of the domino.
                    Dominoes are made using images.]
                    <span style="color:#ff5555">
                        ColoredDominoes is exclusive to HTMLPresets, and to use it you must include
                        eternal_notations_images/dominoes.png in your project and include eternal_notations_images/dominoes.css
                        as a stylesheet in your HTML file.
                    </span>
                </li>
                <li>Factorial [Writes numbers in terms of factorials; like Logarithm, but for factorials instead of exponentiation.]</li>
                <li>FactorialAmount [Writes numbers in terms of the amount of times you'd have to apply the factorial function to 3 to reach them; like SuperLogarithm, but for factorials instead of exponentiation.]</li>
                <li>FactorialScientific [Writes numbers as the product of a mantissa and a factorial; like Scientific, but for factorials instead of exponentiation.]</li>
                <li>FactorialHyperscientific [Writes numbers as a mantissa with the factorial function applied some amount of times; ; like Hyperscientific, but for factorials instead of exponentiation.]</li>
                <li>Factoradic [The <a href="https://en.wikipedia.org/wiki/Factorial_number_system">factorial base</a>]</li>
                <li>SquareRoot [Writes numbers in terms of their square roots]</li>
                <li>CubeRoot [Writes numbers in terms of their cube roots]</li>
                <li class="param_function">Root(degree) [Parameter is a DecimalSource. Writes numbers in terms of a root of some degree; the parameter decides the degree of the root.]</li>
                <li>IncreasingRoot [Writes numbers in terms of a root of some degree; the degree of the root depends on the size of the number.]</li>
                <li>SquareSuperRoot [Writes numbers in terms of their super square roots]</li>
                <li>Tritetrated [Writes numbers in terms of their super cube roots]</li>
                <li class="param_function">SuperRoot(degree) [Parameter is a DecimalSource. Writes numbers in terms of a super root of some degree; the parameter decides the degree of the super root.]</li>
                <li>IncreasingSuperRoot [Writes numbers in terms of a super root of some degree; the degree of the super root depends on the size of the number.]</li>
                <li>Prime [Writes numbers in terms of their prime factorization]</li>
                <li>PsiLetters [Uses <a href="https://googology.fandom.com/wiki/User_blog:PsiCubed2/My_Letter_Notation">PsiCubed2's letter notation</a>]</li>
                <li>PsiDash [Uses <a href="https://googology.fandom.com/wiki/User_blog:PsiCubed2/An_intuitive_lexicographic_ordering_of_numbers_up_to_P10_(%CF%89%5E%CF%89-level)">PsiCubed2's lexiographic ordering</a>]</li>
                <li>OmegaLayers [If you had that many &#945; in <a href="https://veprogames.github.io/omega-layers/">Omega Layers</a>, what layer would you be on and how much of it would you get?]</li>
                <li>OmegaLayersRamped [Like OmegaLayers, but it acts as if the layer requirement increasing started right away and never stopped]</li>
                <li>OmegaLayerNumber [Writes what the layer of that number in OmegaLayers would be called.]</li>
                <li>IncreasingOperator [Moves up the hyperoperator sequence (with a base of 10) as you go to higher numbers]</li>
                <li>IncreasingOperatorBase2 [Moves up the hyperoperator sequence (with a base of 2) as you go to higher numbers]</li>
                <li>IncreasingOperatorBase3 [Moves up the hyperoperator sequence (with a base of 3) as you go to higher numbers]</li>
                <li>Omega [Uses a few particular greek letters for multiples of 1,000, then does an IncreasingOperator-like progression based on 8,000]</li>
                <li>OmegaShort [A version of Omega that moves to higher operators sooner to keep the expressions shorter]</li>
                <li>Fours [Inspired by the <a href="https://en.wikipedia.org/wiki/Four_fours">four fours challenge</a>]</li>
                <li>Triangular [Based on triangular numbers, then goes into layers of recursion]</li>
                <li>Square [Based on square numbers, then goes into layers of recursion]</li>
                <li>Double Factorials [Writes a number as a product of powers of numbers of the form (x!)!]</li>
                <li>Grid [Uses an 8x8 grid where each row represents a binary number, with each row representing the amount of extra squares that would be in the previous row]</li>
                <li>TetrationFloat [Uses a fake floating-point-like system that holds break_eternity-scale numbers in 32 bits]</li>
                <li class="param_function">Polynomial(value) [Parameter is a DecimalSource. Writes a number as a polynomial-like expression where the variable x has a certain value; the parameter determines that value.]</li>
                <li class="param_function">RationalFunction(value) [Parameter is a DecimalSource. Applies FractionMedium to Polynomial to write numbers as rational functions where the parameter x has a certain value; the parameter determines that value.]</li>
                <li>BaseThreeHalves [Writes numbers in base 1.5]</li>
                <li>BasePhi [Writes numbers in the golden ratio base]</li>
                <li>BaseE [Writes numbers in base e]</li>
                <li>BasePi [Writes numbers in base pi]</li>
                <li>Blind [You can't see the numbers]</li>
                <li>PowersOfOne [Whatever number x you give it, this notation writes 1^x]</li>
            </ul>
            <p class="start_hide">
                For more detailed descriptions of the presets, go to the <a href="../index.html">demonstration page</a>.
            </p>
        </div>

        <div class="chapter" style="background-color:#00941e;border:5px solid #00e92f;color:#74ff8f;">
            <h2 class="part_title">Part 2: Notations</h2>
            <p class="start_hide">
                Support for larger numbers and additional notations to choose from are important, but the big thing that
                really sets Eternal Notations apart from AD Notations is that the notations have parameters. Some
                parameters let you make changes to the numbers the notation works in (such as the base of a logarithm,
                or the degree of a root), some let you change thresholds (such as when a scientific
                notation switches to another layer of scientific or the maximum amount of characters in Standard), some make
                aesthetic changes (such as what character is used as the e in scientific notation), and some let you
                create alternate versions of the notation (such as changing the allowed exponent values in scientific,
                the digits of a base, the set of digits in roman numerals, or the set of prefixes in SI). Almost
                all parameters have default values, so you only need to customize them if you want to. Unlike the
                presets, you do use the <code>new</code> operator here, such as <code>new EternalNotations.LettersNotation()</code>
                or <code>new EternalNotations.StandardNotation(1, true, 0, undefined, undefined, 6)</code> (The 
                <code>undefined</code>s
                there cause those parameters to be set to their default values).
                For the sake of familiarity with AD Notations and to differentiate them from the presets, all of the notations
                end in the word "Notation".
                In particular, it should be noted that many notations have one or more "innerNotation" parameters: if a notation
                has a number left over (such as the mantissa in scientific, Standard, etc.), that number will itself be written
                in the innerNotation, which is almost always <code>new DefaultNotation()</code> by default.
            </p>
            <p class="start_hide">
                When this documentation lists function or notation parameters, the types of those parameters have their TypeScript
                type next to them in parentheses. If the arguments provided are not of the appropriate type, expect
                errors or invalid behavior. If the type has an exclamation point at the end of it, that means it is a required
                parameter, which means it does not have a default value and must be included in the parameter list for the notation
                to work. Even after an instance of a notation has been constructed, its parameters are public so they can be changed
                (well, internally some are public while others have getters and setters, but you can treat them all as public).
                Some parameters will throw errors if set to incorrect values (such as trying to give a scientific notation a negative
                base). Parameters of type <code>Decimal</code> accept any <code>DecimalSource</code> in the constructor, but they
                might only accept a Decimal when changing them afterwards (I didn't want to go through and add a bunch more getters
                and setters just for that). Likewise, function arguments of type <code>Decimal</code> will accept any
                <code>DecimalSource</code> (but if the type of a parameter is itself a function that takes a <code>Decimal</code>, then
                that function will require a <code>Decimal</code>, not a <code>DecimalSource</code>). In this documentation,
                parameters (even those that are of function type) will be written in the same color as the rest of the text,
                usable functions will be written in <span class="param_function">yellow</span>.
            </p>
            <p class="start_hide">
                Each notation is its own class, but all of them are extensions of the Notation class. The Notation class
                provides the following data members and methods (I'm only listing the ones that users of the library
                need to be concerned with):
            </p>
            <div class="param_list start_hide">
                <ul>
                    <li>
                        <span class="param_function">format(value) : string --- Writes the given Decimal in this notation.</span>
                        <ul>
                            <li>value ( Decimal ) The Decimal that's being plugged into the notation.</li>
                        </ul>
                    </li>
                    <li>
                        negativeString ( [string, string] ) Most notations don't handle negative numbers directly -
                        instead, they write their absolute value in the notation and then put these two strings around it.
                        Negative numbers have negativeString[0] placed in front of them and negativeString[1] placed after them.
                        Default is ["-", ""].
                    </li>
                    <li>
                        infinityString ( string ) The string that the notation returns for positive infinity. Default is "Infinite".
                    </li>
                    <li>
                        negativeInfinityString ( string | null ) The string used for negative infinity.
                        If this is null, then negative infinity just takes infinityString and wraps it in the negativeString
                        strings like how all the other negatives behave. Default is null.
                    </li>
                    <li>
                        NaNString ( string ) The string that the notation returns for NaN. Default is "???".
                    </li>
                    <li>
                        isInfinite ( (decimal : Decimal) => boolean ) This function is what tests if a number is considered
                        infinite by this notation. The default is decimal.abs().gte(Decimal.dInf), which means "only return true if
                        the Decimal is actually infinite", but by changing this function, this can be changed to, say,
                        mark anything above 2^1024 as infinite.
                    </li>
                    <li>
                        name ( string ) The name of the notation. In general,
                        the names of Notations end in "Notation", but the names of presets do not.
                    </li>
                    <li>
                        <span class="param_function">
                            setNotationGlobals(negativeString, infinityString, negativeInfinityString, NaNString, isInfinite) : this ---
                            Sets the five parameters that all notations have, then returns back the notation it was given but with those changes made.
                            Parameters left undefined here are not changed. All five parameters are optional.
                        </span>
                        <ul>
                            <li>negativeString ( [string, string] ) If this is a pair of strings, negative numbers have negativeString[0] placed in front of them and negativeString[1] placed after them (default is ["-", ""]). The negative string is unaltered if this is undefined.</li>
                            <li>infinityString ( string ) If this is a string, this becomes what the notation returns for positive infinities ("Infinite" by default). The infinity string is unaltered if this is undefined.</li>
                            <li>negativeInfinityString ( string | null ) If this is a string, this becomes what the notation returns for negative infinities. If this is null, then negative infinities use negativeString and infinityString concatenated (this is the default behavior). The negative infinity string is unaltered if this is undefined.</li>
                            <li>NaNString ( string ) If this is a string, this becomes what the notation returns for NaN ("???" by default). The NaN string is unaltered if this is undefined.</li>
                            <li>isInfinite ( (decimal: Decimal) => boolean ) If this is a function, then that function is what tests if a number is considered infinite (the default is decimal.abs().gte(Decimal.dInf), which means "only return true if the Decimal is actually infinite", but by changing this function, this can be changed to, say, mark anything above 2^1024 as infinite). The infinite-checking function is unaltered if this is undefined.</li>
                        </ul>
                    </li>
                    <li>
                        <span class="param_function">
                            setName(name) : this --- Changes the name of the Notation, then gives you back the Notation. (i.e. returns this)
                        </span>
                        <ul>
                            <li>name ( string ) The new name of the notation.</li>
                        </ul>
                    </li>
                </ul>
            </div>
            <p class="start_hide">
                The Notation class is abstract, so it has no constructor of its own. The constructors for other notations do not
                include the six parameters from Notation itself, so if you want to change those, you'll want to use
                <code>setNotationGlobals</code> and <code>setName</code>.
            </p>
            <p class="start_hide">
                Now that we've covered the base class, let's get into the rest of the notations. In the source code, the notations
                are split between two folders inside the src folder: <i>baseline</i> and <i>notations</i>.
                The notations in <i>baseline</i> are the ones that other notations rely on, while the notations in
                <i>notations</i> stand on their own. In theory, you could remove one of the notations in the <i>notations</i>
                folder from the library and all you'd lose would be that notation and a few presets, but the library will probably
                stop working if you remove one of the notations in the <i>baseline</i> folder. Click any of these boxes to open
                up information about that notation.
            </p>
            <h2 style="text-decoration: underline;" class="start_hide">Baseline</h2>
            <div class="subchapter start_hide">
                <h2>DefaultNotation</h2>
                <p class="start_hide">The default way to abbreviate numbers - any leftover numbers in other notations are typically put
                through this to add commas and decimal places. Starts with unabbreviated numbers, then scientific notation, then
                scientific notation with multiple e's, and finally F notation.</p>
                <ul class="param_list start_hide">
                    <li>placesAbove1 ( number ) For numbers above 1, this is the amount of decimal places shown. If this is negative, then the absolute value of this parameter is the amount of significant figures shown (though place values before the decimal point are never cut off). Default is -4.</li>
                    <li>placesBelow1 ( number ) For numbers below 1, this is the amount of decimal places shown. If this is negative, then the absolute value of this parameter is the amount of significant figures shown (though place values before the decimal point are never cut off). Default is -4.</li>
                    <li>commasMin ( Decimal ) Only numbers equal to or greater than this value show commas. Default is 0, which means commas are always shown. If this value is negative, commas are never used.</li>
                    <li>maxnum ( Decimal ) The point at which the notation switches to scientific. Default is 1e12.</li>
                    <li>minnum ( Decimal ) The point below 1 at which the notation switches to scientific with a negative exponent. Default is 1e-6.</li>
                    <li>max_es_in_a_row ( number ) If the scientific representation would have more e's in the front than this, switches to F notation. Default is 5.</li>
                    <li>decimalChar ( string ) The string used as the decimal point. Default is ".".</li>
                    <li>commaChar ( string ) The string used as the comma. Default is ",".</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>AlternateBaseNotation</h2>
                <p class="start_hide">Behaves similarly to DefaultNotation, but supports alternate bases (any whole-number base between 2 and 64, or higher if you provide your own digits) and has more customization.</p>
                <ul class="param_list start_hide">
                    <li>base ( number | string[] ! ) This can be either a number or an array of strings. If the base is a number, the default set of digits for that base is used: 0 through 9, then A through Z, then a through z, then + and /. This notation will throw an error if base is a number above 64, as only 64 default digits are chosen. If base is an array of strings, then those strings are taken as the digits of the base (the number of the base is base.length in this case); bases above 64 are allowed if you provide an array with more than 64 strings.</li>
                    <li>negaDigits ( number ) How many of the digits are negative? Default is 0, which means the digits are from 0 to (base - 1). For example, if negaDigits is 1, the digits are from -1 to (base - 2). For odd bases, set this to (base - 1)/2 for the "balanced" version of that base. The maximum value of negaDigits is the base itself, and the minimum value is -1 (which results in the bijective version of the base); values outside this range will throw an error. You can't set negaDigits to anything other than 0 or -1 if base is given as a number (rather than an array of strings), since digits for negative numbers are not included in the default set of digits. Note that if negaDigits equals -1 or negaDigits equals the base, the amount of decimal places when calling format must be 0, as bijective bases do not support non-whole numbers.</li>
                    <li>placesAbove1 ( number ) For numbers above 1, this is the amount of decimal places shown. If this is negative, then the absolute value of this parameter is the amount of significant figures shown (though place values before the decimal point are never cut off). Default is -4.</li>
                    <li>placesBelow1 ( number ) For numbers below 1, this is the amount of decimal places shown. If this is negative, then the absolute value of this parameter is the amount of significant figures shown (though place values before the decimal point are never cut off). Default is -4.</li>
                    <li>commasMin ( Decimal ) Only numbers equal to or greater than this value show commas. Default is 0, which means commas are always shown. If this value is negative, commas are never used.</li>
                    <li>maxnum ( Decimal ) Numbers greater than or equal to this are converted into scientific notation. Default is base^12.</li>
                    <li>minnum ( Decimal) Numbers less than this are converted into scientific notation. Default is base^-6.</li>
                    <li>max_exps_in_a_row ( number ) If the scientific representation would have more "exponential characters" (like the e in usual scientific notation) in the front than this, switches to F notation. Default is 5.</li>
                    <li>mantissaPower ( Decimal ) Normally, the mantissa in scientific notation is bounded by 1 and the base, which corresponds to the default mantissaPower of 0. If mantissaPower is 1, the bounds are base and base^2, if mantissaPower is 2 then the bounds are base^2 and base^3, and so on. For example, a number normally represented as "2.357e224" would become "23.57e223" with 1 mantissaPower and "235.7e222" with 2 mantissaPower.</li>
                    <li>hypermantissaPower ( Decimal ) Normally, the mantissa in hyperscientific notation is bounded by 1 and the base, which corresponds to the default hypermantissaPower of 0. If hypermantissaPower is 1, the bounds are base and base^^2, if hypermantissaPower is 2 then the bounds are base^^2 and base^^3, and so on. For example, a number normally represented as "2F8" would become "100F7" with 1 hypermantissaPower and "(1e100)F6" with 2 hypermantissaPower.</li>
                    <li>showZeroes ( number ) A positive, zero, or negative number; default is -1. If this is positive, all the decimal places up to (places) are shown, even if some of them are zeroes at the end. If this is zero, all the decimal places up to (places) are shown, even if some are zeroes at the end, but only if not all of the decimal places are zero. If this is negative, zeroes at the end of the decimal places are not shown. If this is negative infinity, then trailing zeroes are always removed, even those before the decimal point.</li>
                    <li>reverseDigits ( boolean ) If this parameter is true, digits are written right-to-left instead of left-to-right. Default is false.</li>
                    <li>commaSpacing ( number ) How many digits are between each comma? Default is 3.</li>
                    <li>commaChars ( string[] ) What are the commas? If this array of strings has only one character, that character is used as the comma. If the array has multiple characters, the array is cycled through, so commaChars[0] is used for the first comma (the comma closest to the ones place), commaChars[1] is used for the second comma, and repeat, going back to commaChars[0] after the last entry. Default is [","].</li>
                    <li>decimalChar ( string ) The character used as the decimal point. Default is ".".</li>
                    <li>expChars ( [[string, string], [string | boolean, string | boolean], [string, string], [string | boolean, string | boolean]] ) An array of four pairs of strings that are used as the between characters for scientific notation. In each pair, the first entry goes before the exponent, the second entry goes after the exponent. expChars[0] takes the place of the e in "1e10", expChars[1] takes the place of the first e in "e1e10", expChars[2] takes the place of the F in "1F10", and expChars[3] takes the place of the F in "F1e10". If expChars[1][0] is a boolean instead of a string: if it's false, then expChars[1][0] is set to be expChars[0][0] with the way this notation formats 1 tacked on the beginning, and if it's true than the 1 is tacked on the end instead. Likewise for expChars[1][1] (expChars[0][1] with a 1 on it), expChars[3][0] (expChars[2][0] with a 1 on it), and expChars[3][1] (expChars[2][1] with a 1 on it). Default is [["$", ""], ["$", ""], ["#", ""], ["#", ""]].</li>
                    <li>negExpChars ( null | [[string, string] | boolean, [string, string]] ) This can either be null or a pair of pairs of strings (in which the first pair of strings may be a boolean instead). Ignore this parameter if it's null, which is the default. If it's a pair of pairs of strings, then the first pair is used like expChars[0] but for negative exponents (so if it's ["d", ""], then 2e-4 would be 2d4 instead), and the second pair is used on small numbers whose reciprocals are large enough to need expChars[1], in which case the second pair indicates that a reciprocal has been taken. If negExpChars[0] is a boolean instead, then if it's true the notation goes directly to the reciprocal behavior for all inputs less than 1, while if it's false then single-iteration inputs don't use negExpChars but multi-iteration ones still use reciprocal behavior.</li>
                    <li>expBefore ( boolean ) If this parameter is true, the exponent comes before the mantissa instead of after. Default is false.</li>
                    <li>hyperexpBefore ( boolean ) If this parameter is true, the hyperexponent comes before the mantissa instead of after. Default is false.</li>
                    <li>precision ( number ) How many digits are actually calculated before the remaining ones are just set to 0; this parameter exists so the notation doesn't bother displaying meaningless digits beyond the limit of floating point precision. Default is however many digits (2^53 - 1) has in that base.</li>
                    <li>
                        specialDigits ( [(placeValue : number, fromStart? : number, outerValue? : number) => boolean, string[]][] ) An array of pairs where each pair contains a (number, number?, number?) -> boolean function and a string array; this parameter allows different place values to use different digits (though the numeric value of the base remains the same).
                        The function's arguments are the place value of the digit (the ones place is place value 0), the digit's distance from the leftmost digit, and the value being inputted, and the function returns true if this digit is to use that set of special digits instead of the normal ones; the string array is the set of special digits to be used.
                        Earlier entries in specialDigits take priority, reverting back to the digits from base if none of the special digits apply or if the one that does apply doesn't have enough entries to represent that digit.
                    </li>
                    <li>
                        concatenation ( null | [boolean, string, string, Notation?] ) If this parameter is not null, then when multiple of the same digit are adjacent, they'll be concatenated into a single digit with a number next to it to indicate the amount of that digit that was concatenated.
                        concatenation[1] and concatenation[2] are placed before and after the concatenation number. If concatenation[3] is undefined, the concatenation number is written in the alternate base itself, otherwise it's written in whatever notation is given. If concatenation[0] is true, then the concatenation number comes after the digit being concatenated, otherwise it comes before.
                        Default is null, i.e. no concatenation occurs.
                    </li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>SignValueNotation</h2>
                <p class="start_hide">Given an array of sign-value numerals such as Roman numerals, converts the number into that sign-value system. For example, given the Roman numerals themselves, 325 becomes CCCXXV.</p>
                <ul class="param_list start_hide">
                    <li>numerals ( [string, Decimal][] ! ) An array of pairs of strings and Decimals. Each pair consists of a numeral (the string) and the value of that numeral (the Decimal).</li>
                    <li>frontToBack ( boolean ) If this is false, numerals are ordered largest to smallest. If this is true, numerals are ordered smallest to largest. Default is false.</li>
                    <li>rounding ( Decimal ) Rounds the value to the nearest multiple of this value. Default is 0, which means no rounding occurs.</li>
                    <li>roundType ( string ) Chooses how to round the value: options are "floor", "round", "ceil"/"ceiling", and "trunc". Any other option will not round at all. Default is "round".</li>
                    <li>max_in_a_row ( number ) The maximum amount of one numeral in a row. Any more of one numeral in a row than this is truncated: for example, MMMMMM would become M(6). Default is 4.</li>
                    <li>separator ( string ) This string is placed between each numeral. Default is the empty string.</li>
                    <li>delimiters ( [string, string] ) A pair of strings that determine what goes before and after the number in a truncated expression like M(6). Default is ["(", ")"].</li>
                    <li>zero ( string ) The string used for numbers closer to zero than the smallest numeral. Default is the empty string.</li>
                    <li>innerNotation ( Notation ) The notation that the number inside a truncated expression is notated with. DefaultNotation is the default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>NestedSignValueNotation</h2>
                <p class="start_hide">A variant of SignValueNotation where the numbers in truncated expressions are themselves notated in this notation. Once the parentheses are deep enough, brackets are introduced to represent the number of parentheses layers, and later on braces are introduced to represent the number of bracket layers.</p>
                <ul class="param_list start_hide">
                    <li>numerals ( [string, Decimal][] ! ) An array of pairs of strings and Decimals. Each pair consists of a numeral (the string) and the value of that numeral (the Decimal).</li>
                    <li>frontToBack ( boolean ) If this is false, numerals are ordered largest to smallest. If this is true, numerals are ordered smallest to largest. Default is false.</li>
                    <li>rounding ( Decimal ) Rounds the value to the nearest multiple of this value. Default is 0, which means no rounding occurs.</li>
                    <li>roundType ( string ) Chooses how to round the value: options are "floor", "round", "ceil"/"ceiling", and "trunc". Any other option will not round at all. Default is "round".</li>
                    <li>max_in_a_row ( number ) The maximum amount of one numeral in a row. Any more of one numeral in a row than this is truncated: for example, MMMMMM would become M(6). Default is 4.</li>
                    <li>max_nestingP ( number ) The maximum layers of nesting of parentheses - any more layers and brackets are introduced. Default is 3.</li>
                    <li>max_nestingB ( number ) The maximum layers of nesting of brackets - any more layers and braces are introduced. Is the same as maxNestingP by default.</li>
                    <li>mantissaPower ( Decimal ) Normally, once brackets are introduced, the number in parentheses is limited to between 1 and the value of the numeral that has the brackets on it, which corresponds to the default of 0 mantissaPower. At 1 mantissaPower, the bounds are (value) and (value^2), and so on. For example, a number represented with Roman numerals as M[VI](I) with 0 mantissaPower becomes M[V](M) with 1 mantissaPower and M[IV](M(M)) with 2 mantissaPower.</li>
                    <li>hypermantissaPower ( Decimal ) Normally, once braces are introduced, the number represented by the brackets and parentheses is limited to between (value of the numeral in question) and (value^value), which corresponds to the default of 1 hypermantissaPower. At 0 hypermantissaPower the bounds are 1 and (value), at 2 hypermantissaPower the bounds are (value^value) and (value^^3) and so on. For example, a number represented with Roman numerals as M{V}(M) with 1 hypermantissaPower becomes M{VI}(I) with 0 hypermantissaPower and M{IV}[M](I) with 2 mantissaPower.</li>
                    <li>separator ( string ) This string is placed between each numeral. Default is the empty string.</li>
                    <li>delimiters ( [[string, string], [string, string], [string, string]] ) An array of three pairs of strings that determine what goes before and after the number in a truncated expression like M(6). The first two strings replace parentheses, the middle two replace brackets, and the last two replace braces. Default is [["(", ")"], ["[", "]"], ["{", "}"]].</li>
                    <li>delimiterPermutation ( number ) The order that the numeral, parentheses, brackets, and braces go in when multiple are present. Default is 9, which corresponds to [numeral, braces, brackets, parentheses]. Each value from 0 to 23 represents a different ordering.</li>
                    <li>zero ( number ) The string used for numbers closer to zero than the smallest numeral. Default is the empty string.</li>
                    <li>
                        showOnLarge ( [boolean, boolean, boolean] ) This parameter shows whether the numeral that the delimiters are placed on is shown - if an entry is true then the numeral and the delimiters are both shown, if it's false then the delimiters and what's inside them are still shown but the numeral they're on is not.
                        showOnLarge[0] is for when parentheses are the highest delimiter, showOnLarge[1] is for when brackets are the highest delimiter, and showOnLarge[2] is for when braces are the highest delimiter.
                    </li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>FractionNotation</h2>
                <p class="start_hide">Writes a number as a fraction that approximates its value. (The approximation is found via continued fractions).</p>
                <ul class="param_list start_hide">
                    <li>precision ( Decimal ! ) If this is positive, the approximation will be within 'precision' of the true value. If this is negative, the approximation will be within 'value'/abs('precision') of the true value. In other words, a positive precision is absolute, a negative precision is proportional.</li>
                    <li>mixedNumber ( boolean ) If this is true, the fractions are written as mixed numbers, i.e. the whole part is separate from the fractional part. Default is false.</li>
                    <li>maxIterations ( number ) The approximation will end after this many continued fractions iterations even if the desired precision has not been reached. Default is Infinity.</li>
                    <li>maxDenominator ( Decimal ) If the approximation's denominator is above this, the approximation ends there. Default is Infinity, which means there is no maximum denominator.</li>
                    <li>strictMaxDenominator ( boolean ) If this parameter is true, then rather than the approximation stopping at the first approximation after the maximum denominator is exceeded, it stops at the last approximation before the maximum denominator is exceeded. Default is false.</li>
                    <li>maxNumerator ( Decimal ) If the approximation's numerator is above this, the approximation ends there. Default is Infinity, which means there is no maximum numerator.</li>
                    <li>strictMaxNumerator ( boolean ) If this parameter is true, then rather than the approximation stopping at the first approximation after the maximum numerator is exceeded, it stops at the last approximation before the maximum numerator is exceeded (unless the approximation is already a whole number, in which case this parameter does not apply). Default is false.</li>
                    <li>delimiters ( [[string, string], [string, string], [string, string]] ) An array of pairs of strings. Each pair of strings is placed around one of the numbers in the fraction to indicate which part of the fraction it is, with the first string in the pair coming before the number and the second string in the pair coming after the number. delimiters[0] goes with the numerator, delimiters[1] goes with the denominator, and delimiters[2] goes with the whole number if mixedNumber is true. Default is [["", ""], ["/", ""], ["", " "]].</li>
                    <li>delimiterPermutation ( number ) The order that the parts of the fraction go in. Default is 1, which corresponds to [whole, numerator, denominator]. Each value from 0 to 5 represents a different ordering.</li>
                    <li>numeratorInnerNotation ( Notation ) The notation that the numerator, and by default the rest of the fraction as well, is abbreviated in. DefaultNotation is the default.</li>
                    <li>wholeInnerNotation ( Notation ) The notation that the whole number in the mixed number fraction is abbreviated with. Is the same as numeratorInnerNotation by default.</li>
                    <li>denominatorInnerNotation ( Notation ) The notation that the denominator in the fraction is abbreviated with. Is the same as numeratorInnerNotation by default.</li>
                    <li>showUnitDenominator ( boolean ) Controls whether the denominator is displayed even if it's 1. Default is false. This does not apply to mixed numbers, since there the fractional part is always hidden if it's zero.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>AppliedFunctionNotation</h2>
                <p class="start_hide">Applies a function to the value, puts a string before it and/or a string after it, then uses InnerNotation to abbreviate the new value.</p>
                <ul class="param_list start_hide">
                    <li>DecimalFunc ( Decimal -> Decimal ) The Decimal -> Decimal function that this notation applies before using InnerNotation. Default is the identity function.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. DefaultNotation is the default.</li>
                    <li>StringFunc ( string -> string ) The string -> string function that this notation applies after using InnerNotation. Default is the identity function.</li>
                    <li>nonFiniteApplied ( boolean ) This is false by default; if this is true, then the functions here are applied even to infinities and NaN. If this is false, then the infinityString, negativeInfinityString, and NaNString of the inner notation, not this notation, are used.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>ConditionalNotation</h2>
                <p class="start_hide">Has an array of notations to choose from, selecting one of them to abbreviate the value based on certain conditions.</p>
                <ul class="param_list start_hide">
                    <li>specialIncluded ( boolean ! ) If this parameter is true, then special numbers (negatives, infinities, etc.) use the conditions to decide which notation to be abbreviated in as well. If this parameter is false, then negatives use negativeSign and their absolute value as usual, and infinities and NaNs still use their respective strings as usual.</li>
                    <li>After that first argument, this notation can take as many arguments as you want to give it. The arguments are of type [Notation, Decimal -> boolean], i.e. pairs where the first entry of each pair is a Notation and the second is a predicate that takes a Decimal. To abbreviate a Decimal value, this notation starts at the beginning of the arguments, and for each argument it checks whether the value satisfies that argument's predicate; if so, that argument's notation is used to abbreviate the value, otherwise the checking moves on to the next argument. An error is thrown if the value doesn't satisfy any of the predicates.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>PredeterminedNotation</h2>
                <p class="start_hide">This notation, no matter what you put in, returns a particular string. Used for things like Blind notation.</p>
                <ul class="param_list start_hide">
                    <li>str ( string ! ) The string that this notation returns.</li>
                </ul>
            </div>
            <p class="start_hide">
                Of the baseline notations, Default, Alternate Base, the Sign Value ones, and Fraction are actual notations themselves,
                while Applied Function, Conditional, and Predetermined are moreso tools for creating other notations.
            </p>
            <h2 style="text-decoration: underline;" class="start_hide">Notations</h2>
            <div class="subchapter start_hide">
                <h2>ScientificNotation</h2>
                <p class="start_hide">Scientific notation. Abbreviates 9 as "9e0" and 10^50 as "1e50". For larger numbers, switches to abbreviations like "e1e17" and eventually "(e^7)1e6", similarly to break_eternity's default toString.</p>
                <ul class="param_list start_hide">
                    <li>maxnum ( Decimal ) Only exponents below this value are allowed - anything higher and the exponent itself is abbreviated in scientific notation. Default is 1e12.</li>
                    <li>max_es_in_a_row ( number ) If the scientific representation would have more e's at the beginning than this, those e's are made into an e^n expression. Default is 5.</li>
                    <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                    <li>engineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed exponent values: if it's three then the exponent will always be a multiple of 3, as in engineering notation. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted exponent values are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0). Default is 1, which corresponds to regular scientific notation.</li>
                    <li>mantissaPower ( Decimal ) Normally, the mantissa in scientific notation is bounded by 1 and the base, which corresponds to the default mantissaPower of 0. If mantissaPower is 1, the bounds are base and base^2, if mantissaPower is 2 then the bounds are base^2 and base^3, and so on. For example, a number normally represented as "2.357e224" would become "23.57e223" with 1 mantissaPower and "235.7e222" with 2 mantissaPower.</li>
                    <li>iteration_zero ( boolean ) If this is true, then numbers less than maxnum will ignore the scientific notation and jump directly to the innerNotation - useful if you want 2 to just be abbreviated as "2" instead of "2e0". Default is false.</li>
                    <li>base ( Decimal ) Scientific notation normally works in powers of 10, but you can change this value to change that. Default is 10. For example, set this to 9, and 81 becomes "1e2".</li>
                    <li>expChars ( [[string, string], [string | boolean, string | boolean], [string, string]] ) An array of three pairs of strings that are used as the between characters for scientific notation. In each pair, the first entry goes before the exponent, the second entry goes after the exponent. expChars[0] takes the place of the e in "1e10", expChars[1] takes the place of the first e in "e1e10", and expChars[2] takes the place of the (e^) in (e^10)4. If expChars[1][0] is a boolean instead of a string: if it's false, then expChars[1][0] is set to be expChars[0][0] with the way mantissaInnerNotation formats 1 tacked on the beginning, and if it's true than the 1 is tacked on the end instead. Likewise for expChars[1][1] (expChars[0][1] with a 1 on it). Default is [["e", ""], ["e", ""], ["(e^", ")"]].</li>
                    <li>negExpChars ( null | [[string, string] | boolean, [string, string]] ) This can either be null or a pair of pairs of strings (in which the first pair of strings may be a boolean instead). Ignore this parameter if it's null, which is the default. If it's a pair of pairs of strings, then the first pair is used like expChars[0] but for negative exponents (so if it's ["d", ""], then 2e-4 would be 2d4 instead), and the second pair is used on small numbers whose reciprocals are large enough to need expChars[1], in which case the second pair indicates that a reciprocal has been taken. If negExpChars[0] is a boolean instead, then if it's true the notation goes directly to the reciprocal behavior for all inputs less than 1, while if it's false then single-iteration inputs don't use negExpChars but multi-iteration ones still use reciprocal behavior.</li>
                    <li>expBefore ( boolean ) If this parameter is true, the exponent comes before the mantissa instead of after. Default is false.</li>
                    <li>superexpAfter ( boolean ) If this parameter is true, (e^n) expressions come after the rest of the number instead of before. Default is false.</li>
                    <li>expMult ( Decimal ) Each exponentiation in the process is multiplied by this value. Default is 1.</li>
                    <li>mantissaInnerNotation ( Notation ) The notation that the numbers within the mantissas are themselves notated with. DefaultNotation is the default.</li>
                    <li>exponentInnerNotation ( Notation ) The notation that the highest exponent is itself notated with. Is the same as mantissaInnerNotation by default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the number in an (e^n) expression is itself notated with. Is the same as exponentInnerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>ScientificIterationsNotation</h2>
                <p class="start_hide">This notation performs scientific notation a certain number of times. 1 iteration means the number is in the form AeB (where A and B are abbreviated using the innerNotation), 2 iterations means the number is in the form AeBeC, and so on.</p>
                <ul class="param_list start_hide">
                    <li>iterations ( number ! ) The amount of iterations.</li>
                    <li>max_es_in_a_row ( number ) If the scientific representation would have more e's at the beginning than this, those e's are made into an e^n expression. Default is 5.</li>
                    <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                    <li>engineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed exponent values: if it's three then the exponent will always be a multiple of 3, as in engineering notation. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted exponent values are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0). Default is 1, which corresponds to regular scientific notation.</li>
                    <li>mantissaPower ( Decimal ) Normally, the mantissa in scientific notation is bounded by 1 and the base, which corresponds to the default mantissaPower of 0. If mantissaPower is 1, the bounds are base and base^2, if mantissaPower is 2 then the bounds are base^2 and base^3, and so on. For example, a number normally represented as "2.357e224" would become "23.57e223" with 1 mantissaPower and "235.7e222" with 2 mantissaPower.</li>
                    <li>base ( Decimal ) Scientific notation normally works in powers of 10, but you can change this value to change that. Default is 10. For example, set this to 9, and 81 becomes "1e2".</li>
                    <li>expChars ( [[string, string], [string | boolean, string | boolean], [string, string]] ) An array of three pairs of strings that are used as the between characters for scientific notation. In each pair, the first entry goes before the exponent, the second entry goes after the exponent. expChars[0] takes the place of the e in "1e10", expChars[1] takes the place of the first e in "e1e10", and expChars[2] takes the place of the (e^) in (e^10)4. If expChars[1][0] is a boolean instead of a string: if it's false, then expChars[1][0] is set to be expChars[0][0] with the way mantissaInnerNotation formats 1 tacked on the beginning, and if it's true than the 1 is tacked on the end instead. Likewise for expChars[1][1] (expChars[0][1] with a 1 on it). Default is [["e", ""], ["e", ""], ["(e^", ")"]].</li>
                    <li>negExpChars ( null | [[string, string] | boolean, [string, string]] ) This can either be null or a pair of pairs of strings (in which the first pair of strings may be a boolean instead). Ignore this parameter if it's null, which is the default. If it's a pair of pairs of strings, then the first pair is used like expChars[0] but for negative exponents (so if it's ["d", ""], then 2e-4 would be 2d4 instead), and the second pair is used on small numbers whose reciprocals are large enough to need expChars[1], in which case the second pair indicates that a reciprocal has been taken. If negExpChars[0] is a boolean instead, then if it's true the notation goes directly to the reciprocal behavior for all inputs less than 1, while if it's false then single-iteration inputs don't use negExpChars but multi-iteration ones still use reciprocal behavior.</li>
                    <li>expBefore ( boolean ) If this parameter is true, the exponent comes before the mantissa instead of after. Default is false.</li>
                    <li>superexpAfter ( boolean ) If this parameter is true, (e^n) expressions come after the rest of the number instead of before. Default is false.</li>
                    <li>expMult ( Decimal ) Each exponentiation in the process is multiplied by this value. Default is 1.</li>
                    <li>mantissaInnerNotation ( Notation ) The notation that the numbers within the mantissas are themselves notated with. DefaultNotation is the default.</li>
                    <li>exponentInnerNotation ( Notation ) The notation that the highest exponent is itself notated with. Is the same as mantissaInnerNotation by default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the number in an (e^n) expression is itself notated with. Is the same as exponentInnerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>LogarithmNotation</h2>
                <p class="start_hide">Abbreviates numbers in terms of their logarithm, so 10^12 is "e12" and 2 is "e0.301".</p>
                <ul class="param_list start_hide">
                    <li>iterations ( number ) The amount of logarithm iterations: 1 is basic Logarithm notation, 2 is double Logarithm, and so on. This can be negative: with -1 iterations, 2 would be "lg100".</li>
                    <li>max_es_in_a_row ( number ) If the logarithm representation would have more e's at the beginning than this, those e's are made into an e^n expression. Default is 5.</li>
                    <li>base ( Decimal ) This notation normally works in powers of 10, but you can change this value to change that. Default is 10. For example, set this to 9, and 81 becomes "e2".</li>
                    <li>negLogBehavior ( boolean ) If this parameter is true, then numbers between 0 and 1 are treated as reciprocals, meaning their first logarithm is made negative before the rest of the iterations. Default is true.</li>
                    <li>expChars ( [[string, string], [string, string], [string, string]] ) An array of three pairs of strings that are used as the characters to indicate logarithm notation. In each pair, the first entry goes before the number, the second entry goes after the number. expChars[0] takes the place of the e in "e10", expChars[1] takes the place of the first e in "ee10" (expChars[0] is for the innermost logarithm, expChars[1] is for the outer ones), and expChars[2] takes the place of the (e^) in (e^10)4. Default is [["e", ""], ["e", ""], ["(e^", ")"]].</li>
                    <li>logChars ( [[string, string], [string, string], [string, string]] | null ) An equivalent of expChars used for a logarithm of negative iterations. Default is [["lg", ""], ["lg", ""], ["(lg^", ")"]]. If this is set to null instead of a pair of strings, negative iterations just show negative iterations of expChars[2], such as e^-1.</li>
                    <li>superexpAfter ( boolean ) This is false by default; if it's true, an (e^n) expression comes after the number instead of before.</li>
                    <li>baseShown ( number ) This is 0 by default. If this is 0, the base is not shown. If this is positive, the base is shown at the beginning of the expression. If this is negative, the base is shown at the end of the expression.</li>
                    <li>expMult ( Decimal ) On each logarithm iteration, the result is multiplied by this number. Default is 1.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. DefaultNotation is the default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the number in an (e^n) expression is itself notated with. Is the same as innerNotation by default.</li>
                    <li>baseInnerNotation ( Notation ) The notation that the base within the expression, if included, is itself notated with. Is the same as innerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>MultiLogarithmNotation</h2>
                <p class="start_hide">A variant of logarithm notation that uses a different amount of logarithm iterations depending on how large the number is.</p>
                <ul class="param_list start_hide">
                    <li>maxnum ( Decimal ) Only numbers below this value are allowed to show up on their own - anything higher and the amount of iterations increases. Default is 1e12.</li>
                    <li>max_es_in_a_row ( number ) If the logarithm representation would have more e's at the beginning than this, those e's are made into an e^n expression. Default is 5.</li>
                    <li>minIterations ( number ) The minimum amount of logarithm iterations. Default is 1.</li>
                    <li>base ( Decimal ) This notation normally works in powers of 10, but you can change this value to change that. Default is 10. For example, set this to 9, and 81 becomes "e2".</li>
                    <li>engineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed iteration amounts: if it's three then the amount of iterations will always be a multiple of 3. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted iteration amounts are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0).</li>
                    <li>negLogBehavior ( boolean ) If this parameter is true, then numbers between 0 and 1 are treated as reciprocals, meaning their first logarithm is made negative before the rest of the iterations. Default is true.</li>
                    <li>expChars ( [[string, string], [string, string], [string, string]] ) An array of three pairs of strings that are used as the characters to indicate logarithm notation. In each pair, the first entry goes before the number, the second entry goes after the number. expChars[0] takes the place of the e in "e10", expChars[1] takes the place of the first e in "ee10" (expChars[0] is for the innermost logarithm, expChars[1] is for the outer ones), and expChars[2] takes the place of the (e^) in (e^10)4. Default is [["e", ""], ["e", ""], ["(e^", ")"]].</li>
                    <li>logChars ( [[string, string], [string, string], [string, string]] | null ) An equivalent of expChars used for a logarithm of negative iterations. Default is [["lg", ""], ["lg", ""], ["(lg^", ")"]]. If this is set to null instead of a pair of strings, negative iterations just show negative iterations of expChars[2], such as e^-1.</li>
                    <li>superexpAfter ( boolean ) This is false by default; if it's true, an (e^n) expression comes after the number instead of before.</li>
                    <li>baseShown ( number ) This is 0 by default. If this is 0, the base is not shown. If this is positive, the base is shown at the beginning of the expression. If this is negative, the base is shown at the end of the expression.</li>
                    <li>expMult ( Decimal ) On each logarithm iteration, the result is multiplied by this number. Default is 1.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. DefaultNotation is the default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the number in an (e^n) expression is itself notated with. Is the same as innerNotation by default.</li>
                    <li>baseInnerNotation ( Notation ) The notation that the base within the expression, if included, is itself notated with. Is the same as innerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>HyperscientificNotation</h2>
                <p class="start_hide">Scientific notation, but with tetration instead of exponentiation. Abbreviates 9 as "9F0", 1,000 as "3F1", and 10^10^10^10 as "1F4".</p>
                <ul class="param_list start_hide">
                    <li>maxnum ( Decimal ) Only exponents below this value are allowed - anything higher and the exponent itself is abbreviated in hyperscientific notation. Default is 1e10.</li>
                    <li>max_Fs_in_a_row ( number ) If the hyperscientific representation would have more F's at the beginning than this, those F's are made into an F^n expression. Default is 5.</li>
                    <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                    <li>engineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed hyperexponent values: if it's three then the hyperexponent will always be a multiple of 3, like in engineering notation. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted hyperexponent values are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0). Default is 1, which corresponds to regular hyperscientific notation.</li>
                    <li>mantissaPower ( Decimal ) Normally, the mantissa in hyperscientific notation is bounded by 1 and the base, which corresponds to the default mantissaPower of 0. If mantissaPower is 1, the bounds are base and base^^2, if mantissaPower is 2 then the bounds are base^^2 and base^^3, and so on. For example, a number normally represented as "2F3" would become "100F2" with 1 mantissaPower and "(1e100)F1" with 2 mantissaPower.</li>
                    <li>iteration_zero ( boolean ) If this is true, then numbers less than maxnum will ignore the scientific notation and jump directly to the innerNotation - useful if you want 2 to just be abbreviated as "2" instead of "2F0". Default is false.</li>
                    <li>base ( Decimal ) Hyperscientific notation normally works in tetra-powers of 10, but you can change this value to change that. Default is 10. For example, set this to 9, and 81 becomes "2F1".</li>
                    <li>expChars ( [[string, string], [string | boolean, string | boolean], [string, string]] ) An array of three pairs of strings that are used as the between characters for scientific notation. In each pair, the first entry goes before the hyperexponent, the second entry goes after the hyperexponent. expChars[0] takes the place of the F in "1F10", expChars[1] takes the place of the first F in "F1F10", and expChars[2] takes the place of the (F^) in (F^10)4. If expChars[1][0] is a boolean instead of a string: if it's false, then expChars[1][0] is set to be expChars[0][0] with the way mantissaInnerNotation formats 1 tacked on the beginning, and if it's true than the 1 is tacked on the end instead. Likewise for expChars[1][1] (expChars[0][1] with a 1 on it). Default is [["F", ""], ["F", ""], ["(F^", ")"]].</li>
                    <li>negExpChars ( null | [[string, string] | boolean, [string, string]] ) This can either be null or a pair of pairs of strings (in which the first pair of strings may be a boolean instead). Ignore this parameter if it's null, which is the default. If it's a pair of pairs of strings, then the first pair is used like expChars[0] but for negative exponents (so if it's ["d", ""], then 2e-4 would be 2d4 instead), and the second pair is used on small numbers whose reciprocals are large enough to need expChars[1], in which case the second pair indicates that a reciprocal has been taken. If negExpChars[0] is a boolean instead, then if it's true the notation goes directly to the reciprocal behavior for all inputs less than 1, while if it's false then single-iteration inputs don't use negExpChars but multi-iteration ones still use reciprocal behavior.</li>
                    <li>expBefore ( boolean ) If this parameter is true, the hyperexponent comes before the mantissa instead of after. Default is false.</li>
                    <li>superexpAfter ( boolean ) If this parameter is true, (e^n) expressions come after the rest of the number instead of before. Default is false.</li>
                    <li>formatNegatives ( boolean ) If this parameter is false, negative numbers are just formatted using their absolute value with negativeString around it, like in most notations. If this parameter is true, negative numbers are formatted in hyperscientific directly. Default is true.</li>
                    <li>expMult ( Decimal ) On each single exponentiation in the tetration, the exponent is multiplied by this value. Default is 1.</li>
                    <li>hyperexpMult ( Decimal ) Each hyperexponent in the process is multiplied by this value. Default is 1.</li>
                    <li>mantissaInnerNotation ( Notation ) The notation that the numbers within the mantissas are themselves notated with. DefaultNotation is the default.</li>
                    <li>exponentInnerNotation ( Notation ) The notation that the highest hyperexponent is itself notated with. Is the same as mantissaInnerNotation by default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the number in an (F^n) expression is itself notated with. Is the same as exponentInnerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>HyperscientificIterationsNotation</h2>
                <p class="start_hide">This notation performs hyperscientific notation a certain number of times. 1 iteration means the number is in the form AFB (where A and B are abbreviated using the innerNotation), 2 iterations means the number is in the form AFBFC, and so on.</p>
                <ul class="param_list start_hide">
                    <li>iterations ( number ! ) The amount of iterations.</li>
                    <li>max_Fs_in_a_row ( number ) If the hyperscientific representation would have more F's at the beginning than this, those F's are made into an F^n expression. Default is 5.</li>
                    <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                    <li>engineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed hyperexponent values: if it's three then the hyperexponent will always be a multiple of 3, like in engineering notation. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted hyperexponent values are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0). Default is 1, which corresponds to regular hyperscientific notation.</li>
                    <li>mantissaPower ( Decimal ) Normally, the mantissa in hyperscientific notation is bounded by 1 and the base, which corresponds to the default mantissaPower of 0. If mantissaPower is 1, the bounds are base and base^^2, if mantissaPower is 2 then the bounds are base^^2 and base^^3, and so on. For example, a number normally represented as "2F3" would become "100F2" with 1 mantissaPower and "(1e100)F1" with 2 mantissaPower.</li>
                    <li>base ( Decimal ) Hyperscientific notation normally works in tetra-powers of 10, but you can change this value to change that. Default is 10. For example, set this to 9, and 81 becomes "2F1".</li>
                    <li>expChars ( [[string, string], [string | boolean, string | boolean], [string, string]] ) An array of three pairs of strings that are used as the between characters for scientific notation. In each pair, the first entry goes before the hyperexponent, the second entry goes after the hyperexponent. expChars[0] takes the place of the F in "1F10", expChars[1] takes the place of the first F in "F1F10", and expChars[2] takes the place of the (F^) in (F^10)4. If expChars[1][0] is a boolean instead of a string: if it's false, then expChars[1][0] is set to be expChars[0][0] with the way mantissaInnerNotation formats 1 tacked on the beginning, and if it's true than the 1 is tacked on the end instead. Likewise for expChars[1][1] (expChars[0][1] with a 1 on it). Default is [["F", ""], ["F", ""], ["(F^", ")"]].</li>
                    <li>negExpChars ( null | [[string, string] | boolean, [string, string]] ) This can either be null or a pair of pairs of strings (in which the first pair of strings may be a boolean instead). Ignore this parameter if it's null, which is the default. If it's a pair of pairs of strings, then the first pair is used like expChars[0] but for negative exponents (so if it's ["d", ""], then 2e-4 would be 2d4 instead), and the second pair is used on small numbers whose reciprocals are large enough to need expChars[1], in which case the second pair indicates that a reciprocal has been taken. If negExpChars[0] is a boolean instead, then if it's true the notation goes directly to the reciprocal behavior for all inputs less than 1, while if it's false then single-iteration inputs don't use negExpChars but multi-iteration ones still use reciprocal behavior.</li>
                    <li>expBefore ( boolean ) If this parameter is true, the hyperexponent comes before the mantissa instead of after. Default is false.</li>
                    <li>superexpAfter ( boolean ) If this parameter is true, (e^n) expressions come after the rest of the number instead of before. Default is false.</li>
                    <li>formatNegatives ( boolean ) If this parameter is false, negative numbers are just formatted using their absolute value with negativeString around it, like in most notations. If this parameter is true, negative numbers are formatted in hyperscientific directly. Default is false.</li>
                    <li>expMult ( Decimal ) On each single exponentiation in the tetration, the exponent is multiplied by this value. Default is 1.</li>
                    <li>hyperexpMult ( Decimal ) Each hyperexponent in the process is multiplied by this value. Default is 1.</li>
                    <li>mantissaInnerNotation ( Notation ) The notation that the numbers within the mantissas are themselves notated with. DefaultNotation is the default.</li>
                    <li>exponentInnerNotation ( Notation ) The notation that the highest hyperexponent is itself notated with. Is the same as mantissaInnerNotation by default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the number in an (F^n) expression is itself notated with. Is the same as exponentInnerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>SuperLogarithmNotation</h2>
                <p class="start_hide">Abbreviates numbers in terms of their super-logarithm, so 10 is "F1" and 10^10^10 is "F3". Uses the linear approximation of tetration.</p>
                <ul class="param_list start_hide">
                    <li>iterations ( number ) The amount of logarithm iterations: 1 is basic Super-Logarithm notation, 2 is double Super-Logarithm, and so on. This can be negative: with -1 iterations, 2 would be "slg10,000,000,000".</li>
                    <li>max_Fs_in_a_row ( number ) If the super-logarithm representation would have more F's at the beginning than this, those F's are made into an F^n expression. Default is 5.</li>
                    <li>base ( Decimal ) This notation normally works in tetra-powers of 10, but you can change this value to change that. Default is 10. For example, set this to 9, and 81 becomes "F1.315".</li>
                    <li>expChars ( [[string, string], [string, string], [string, string]] ) An array of three pairs of strings that are used as the characters to indicate logarithm notation. In each pair, the first entry goes before the number, the second entry goes after the number. expChars[0] takes the place of the F in "F10", expChars[1] takes the place of the first F in "FF10" (expChars[0] is for the innermost logarithm, expChars[1] is for the outer ones), and expChars[2] takes the place of the (F^) in (F^10)4. Default is [["F", ""], ["F", ""], ["(F^", ")"]].</li>
                    <li>logChars ( [[string, string], [string, string], [string, string]] | null ) An equivalent of expChars used for a logarithm of negative iterations. Default is [["slg", ""], ["slg", ""], ["(slg^", ")"]]. If this is set to null instead of a pair of strings, negative iterations just show negative iterations of expChars[2], such as F^-1.</li>
                    <li>superexpAfter ( boolean ) This is false by default; if it's true, an (F^n) expression comes after the number instead of before.</li>
                    <li>baseShown ( number ) This is 0 by default. If this is 0, the base is not shown. If this is positive, the base is shown at the beginning of the expression. If this is negative, the base is shown at the end of the expression.</li>
                    <li>formatNegatives ( boolean ) If this parameter is false, negative numbers are just formatted using their absolute value with negativeString around it, like in most notations. If this parameter is true, negative numbers are formatted in super-logarithm notation directly. Default is false.</li>
                    <li>expMult ( Decimal ) On each logarithm iteration within the super-logarithm, the result is multiplied by this number. Default is 1.</li>
                    <li>hyperexpMult ( Decimal ) On each super-logarithm iteration within, the result is multiplied by this number. Default is 1.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. DefaultNotation is the default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the number in an (F^n) expression is itself notated with. Is the same as innerNotation by default.</li>
                    <li>baseInnerNotation ( Notation ) The notation that the base within the expression, if included, is itself notated with. Is the same as innerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>MultiSuperLogarithmNotation</h2>
                <p class="start_hide">A variant of super-logarithm notation that uses a different amount of super-logarithm iterations depending on how large the number is.</p>
                <ul class="param_list start_hide">
                    <li>maxnum ( Decimal ) Only numbers below this value are allowed to show up on their own - anything higher and the amount of iterations increases. Default is 1e10.</li>
                    <li>max_Fs_in_a_row ( number ) If the super-logarithm representation would have more F's at the beginning than this, those F's are made into an F^n expression. Default is 5.</li>
                    <li>minIterations ( number ) The minimum amount of logarithm iterations. Default is 1.</li>
                    <li>base ( Decimal ) This notation normally works in tetra-powers of 10, but you can change this value to change that. Default is 10. For example, set this to 9, and 81 becomes "F1.315".</li>
                    <li>engineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed iteration amounts: if it's three then the amount of iterations will always be a multiple of 3. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted iteration amounts are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0).</li>
                    <li>expChars ( [[string, string], [string, string], [string, string]] ) An array of three pairs of strings that are used as the characters to indicate logarithm notation. In each pair, the first entry goes before the number, the second entry goes after the number. expChars[0] takes the place of the F in "F10", expChars[1] takes the place of the first F in "FF10" (expChars[0] is for the innermost logarithm, expChars[1] is for the outer ones), and expChars[2] takes the place of the (F^) in (F^10)4. Default is [["F", ""], ["F", ""], ["(F^", ")"]].</li>
                    <li>logChars ( [[string, string], [string, string], [string, string]] | null ) An equivalent of expChars used for a logarithm of negative iterations. Default is [["slg", ""], ["slg", ""], ["(slg^", ")"]]. If this is set to null instead of a pair of strings, negative iterations just show negative iterations of expChars[2], such as F^-1.</li>
                    <li>superexpAfter ( boolean ) This is false by default; if it's true, an (F^n) expression comes after the number instead of before.</li>
                    <li>baseShown ( number ) This is 0 by default. If this is 0, the base is not shown. If this is positive, the base is shown at the beginning of the expression. If this is negative, the base is shown at the end of the expression.</li>4
                    <li>formatNegatives ( boolean ) If this parameter is false, negative numbers are just formatted using their absolute value with negativeString around it, like in most notations. If this parameter is true, negative numbers are formatted in super-logarithm notation directly. Default is false.</li>
                    <li>expMult ( Decimal ) On each logarithm iteration within the super-logarithm, the result is multiplied by this number. Default is 1.</li>
                    <li>hyperexpMult ( Decimal ) On each super-logarithm iteration within, the result is multiplied by this number. Default is 1.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. DefaultNotation is the default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the number in an (F^n) expression is itself notated with. Is the same as innerNotation by default.</li>
                    <li>baseInnerNotation ( Notation ) The notation that the base within the expression, if included, is itself notated with. Is the same as innerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>ExpandedDefaultNotation</h2>
                <p class="start_hide">The progression of this notation is similar to Default notation: unabbreviated, then scientific, then hyperscientific. However, this notation is not itself a default: instead, it lets you customize the process.</p>
                <ul class="param_list start_hide">
                    <li>maxnum ( Decimal ) The point at which the notation switches to scientific. Default is 1e12.</li>
                    <li>minnum ( Decimal ) The point below 1 at which the notation switches to scientific with a negative exponent. Default is 1e-6.</li>
                    <li>max_es_in_a_row ( number ) If the scientific representation would have more e's than this, switches to F notation. Default is 5.</li>
                    <li>logBase ( Decimal ) The base of the scientific notation. Default is 10.</li>
                    <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                    <li>mantissaPower ( Decimal ) Normally, the mantissa in scientific notation is bounded by 1 and the base, which corresponds to the default mantissaPower of 0. If mantissaPower is 1, the bounds are base and base^2, if mantissaPower is 2 then the bounds are base^2 and base^3, and so on. For example, a number normally represented as "2.357e224" would become "23.57e223" with 1 mantissaPower and "235.7e222" with 2 mantissaPower.</li>
                    <li>hypermantissaPower ( Decimal ) Normally, the mantissa in hyperscientific notation is bounded by 1 and the base, which corresponds to the default hypermantissaPower of 0. If hypermantissaPower is 1, the bounds are base and base^^2, if hypermantissaPower is 2 then the bounds are base^^2 and base^^3, and so on. For example, a number normally represented as "2F8" would become "100F7" with 1 hypermantissaPower and "(1e100)F6" with 2 hypermantissaPower.</li>
                    <li>engineerings ( Decimal | DecimalSource[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed exponent values: if it's three then the exponent will always be a multiple of 3, as in engineering notation. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted exponent values are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0). Default is 1, which corresponds to regular scientific notation.</li>
                    <li>hyperengineerings ( Decimal | DecimalSource[] ) Same as engineerings, but for the hyperexponent instead.</li>
                    <li>expChars ( [[string, string], [string | boolean, string | boolean], [string, string], [string | boolean, string | boolean]] ) An array of four pairs of strings that are used as the between characters for scientific notation. In each pair, the first entry goes before the exponent, the second entry goes after the exponent. expChars[0] takes the place of the e in "1e10", expChars[1] takes the place of the first e in "e1e10", expChars[2] takes the place of the F in "1F10", and expChars[3] takes the place of the F in "F1e10". If expChars[1][0] is a boolean instead of a string: if it's false, then expChars[1][0] is set to be expChars[0][0] with the way this notation formats 1 tacked on the beginning, and if it's true than the 1 is tacked on the end instead. Likewise for expChars[1][1] (expChars[0][1] with a 1 on it), expChars[3][0] (expChars[2][0] with a 1 on it), and expChars[3][1] (expChars[2][1] with a 1 on it). Default is [["e", ""], ["e", ""], ["F", ""], ["F", ""]].</li>
                    <li>negExpChars ( null | [[string, string] | boolean, [string, string]] ) This can either be null or a pair of pairs of strings (in which the first pair of strings may be a boolean instead). Ignore this parameter if it's null, which is the default. If it's a pair of pairs of strings, then the first pair is used like expChars[0] but for negative exponents (so if it's ["d", ""], then 2e-4 would be 2d4 instead), and the second pair is used on small numbers whose reciprocals are large enough to need expChars[1], in which case the second pair indicates that a reciprocal has been taken. If negExpChars[0] is a boolean instead, then if it's true the notation goes directly to the reciprocal behavior for all inputs less than 1, while if it's false then single-iteration inputs don't use negExpChars but multi-iteration ones still use reciprocal behavior.</li>
                    <li>expBefore ( boolean ) If this parameter is true, the exponent comes before the mantissa instead of after. Default is false.</li>
                    <li>hyperexpBefore ( boolean ) If this parameter is true, the hyperexponent comes before the mantissa instead of after. Default is false.</li>
                    <li>expMult ( Decimal ) Each exponentiation in the process is multiplied by this value. Default is 1.</li>
                    <li>hyperexpMult ( Decimal ) Each hyperexponent in the process is multiplied by this value. Default is 1.</li>
                    <li>mantissaInnerNotation ( Notation ) The notation that the mantissa is itself notated with. DefaultNotation is the default.</li>
                    <li>exponentInnerNotation ( Notation ) The notation that the exponent is itself notated with. Is the same as mantissaInnerNotation by default.</li>
                    <li>hyperexpFormat ( [boolean, boolean] ) A pair of booleans that determines whether the numbers in a hyperscientific expression are notated using ExpandedDefaultNotation itself rather than the innerNotations. The first entry is for the mantissa, the second is for the hyperexponent. This only applies to "xFy" expressions; "Fx" expressions (where x is over the maxnum) always formats x in ExpandedDefaultNotation itself. Default is [false, false].</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>StandardNotation</h2>
                <p class="start_hide">Uses the names of large numbers to abbreviate them: a million is 1 M, two billion is 2 B, and so on. Larger names use the -illion scheme devised by Jonathan Bowers.</p>
                <ul class="param_list start_hide">
                    <li>dialect ( number ) Controls which set of prefixes is used. Dialect 0 is MathCookie's Standard (the set of prefixes chosen by the creator of eternal_notations), dialect 1 uses the prefixes from Antimatter Dimensions, and dialect 2 is Aarex's Abbreviation System by Aarex Tiaokhiao. Default is 0 (MathCookie's Standard). Any value other than 0, 1, or 2 will default back to 0.</li>
                    <li>longScale ( boolean ) The short scale is used if this is false, the long scale is used if this is true. Default is false.</li>
                    <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                    <li>entriesLimit ( number ) How many "entries" of a single tier can show up before the notation cuts off with an ellipsis. Default is 6. For example, NNgNeMc-NNgNeMl-NNgNe has 3 entries.</li>
                    <li>charLimit ( number ) How many characters long the abbreviation can be (not including the number at the front, just the -illion prefix) before the notation cuts off with an ellipsis. Default is 100.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. DefaultNotation is the default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>LettersNotation</h2>
                <p class="start_hide">
                    Each power of 1,000 gets a letter of the alphabet, so 1,000 is 1a, 55,430,000 is 55.43b, 10^15 is 1e, and so on. aa comes after z, aaa comes after zz.
                    100A means that there would be 100 lowercase letters in the full expression, 1Aa means 1,000A, 1Ad means (10^12)A, 100B means there would be 100 lowercase letters in an expression beginning with A,
                    200C means that there would be 200 lowercase letters in an expression beginning with B, and so on. AA comes after Z. 100@ means there would be 100 uppercase letters in a full expression, 1 @a means 1,000@, and so on.
                </p>
                <ul class="param_list start_hide">
                    <li>letters ( [string[], string[], string[]] ) An array of three arrays of strings. The first array is the lowercase letters, the second array is the uppercase letters, and the third is the "third letters", of which @ is the only one in the default system. The default setting has the 26 lowercase letters as the first array, the 26 uppercase letters as the second array, and a single-entry array containing only @ as the third array.</li>
                    <li>
                        negaLetters ( number | [number, number, number] ) If you think of the letters as being numbers in an alternate base, how many of the digits in the base are negative? Default is -1, which corresponds to a bijective base. 0 would be a regular base, i.e. including a letter for zero.
                        This parameter must be between -1 and (the amount of letters - 2). If this parameter is a single number, then that's the amount of negative letters for all three letter types, but if it's an array then negaLetters[0] is for the lowercase letters, negaLetters[1] is for the uppercase letters, and negaLetters[2] is for the third letters.
                    </li>
                    <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                    <li>base ( Decimal ) The number that the letters represent powers of. Default is 1,000.</li>
                    <li>max_letters ( number ) The highest amount of letters of a single tier - any more, and they're truncated into the next tier. Default is 12.</li>
                    <li>between ( string ) This string goes between the number and the letters. Default is the empty string.</li>
                    <li>separator ( string ) This string goes between each letter. Default is the empty string.</li>
                    <li>hyperseparator ( string ) This string goes between each tier of letters. Default is the empty string.</li>
                    <li>alwaysHyperseparate ( boolean ) If this parameter is true, hyperseparators appear for every letter tier after the first non-empty one, even if some of the later ones are empty (and thus would normally skip their hyperseparator). Default is false.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. DefaultNotation is the default.</li>
                    <li>lettersOrder ( number ) The order that the different types of letters go in when multiple are present. Default is 0, which corresponds to [third, uppercase, lowercase]. Each value from 0 to 5 represents a different ordering.</li>
                    <li>reverseLetters ( boolean ) If this is true, the letters of a single type are written right to left instead of left to right. Default is false.</li>
                    <li>mantissaAfter ( boolean ) If this is true, the number comes after all the letters instead of before. Default is false.</li>
                    <li>divisionChar ( [string, string] ) The strings used to represent that the letter expression is actually its reciprocal (for numbers below 1); divisionChar[0] goes before the letter expression, divisionChar[1] goes after the letter expression. Default is ["/", ""].</li>
                    <li>
                        specialLetters ( [[(placeValue : number, fromStart? : number, outerValue? : number) => boolean, string[]][], [(placeValue : number, fromStart? : number, outerValue? : number) => boolean, string[]][], [(placeValue : number, fromStart? : number, outerValue? : number) => boolean, string[]][]] )
                        An array of three arrays of pairs where each pair contains a (number, number?, number?) -> boolean function and a string array; this parameter allows different place values to use different letters (though the amount of letters remains the same). specialLetters[0] is for the lowercase letters, specialLetters[1] is for the uppercase letters, and specialLetters[2] is for the third letters.
                        The function's arguments are the place value of the letter (the last place is place value 0), the letter's distance from the leftmost letter, and the "value" of that letter string (a is 1, z is 26, aa is 27, etc.), and the function returns true if this letter is to use that set of special letters instead of the normal ones; the string array is the set of special letters to be used.
                        Earlier entries in specialLetters take priority, reverting back to the regular letters if none of the special letters apply or if the one that does apply doesn't have enough entries to represent that letter.
                    </li>
                    <li>fixedLetters ( [[number, string][], [number, string][], [number, string][]] ) If the value of the letter string matches any of the numbers in that letter type's array in here (fixedLetters[0] is for the lowercase letters, fixedLetters[1] is for the uppercase letters, fixedLetters[2] is for the third letters), the regular letters are not used - instead, the letter string is just set to that number's corresponding string in this array. Default is [[], [], []], i.e. there are no fixed letters.</li>
                    <li>
                        concatenation ( [null | [boolean, string, string, Notation?], null | [boolean, string, string, Notation?], null | [boolean, string, string, Notation?]] ) concatenation[0] is for lowercase letters, concatenation[1] is for uppercase letters, concatenation[2] is for third letters.
                        If a concatenation entry is not null, then when multiple of the same letter of a single tier are adjacent, they'll be concatenated into a single letter with a number next to it to indicate the amount of that digit that was concatenated.
                        concatenation[n][1] and concatenation[n][2] are placed before and after the concatenation number. If concatenation[n][3] is undefined, the concatenation number is written as a letter string itself, otherwise it's written in whatever notation is given. If concatenation[n][0] is true, then the concatenation number comes after the letter being concatenated, otherwise it comes before.
                        Default is [null, null, null], i.e. no concatenation occurs.
                    </li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>SINotation</h2>
                <p class="start_hide">Abbreviates a number using the SI prefixes: 1,000 is 1 k, 10^12 is 1 T, 10^30 is 1 Q, 10^33 is 1 kQ, 10^72 is 1 TQQ, 10^300 is 1 Q[10], and so on.</p>
                <ul class="param_list start_hide">
                    <li>logBase ( Decimal ) The base used by the prefixes. Default is 10.</li>
                    <li>prefixes ( [string, Decimal][] ) An array of pairs of strings and Decimals used as the prefixes. Each pair consists of a prefix (the string) and the value of that prefix as an exponent on logBase (the Decimal). Default is [["Q", 30], ["R", 27], ["Y", 24], ["Z", 21], ["E", 18], ["P", 15], ["T", 12], ["G", 9], ["M", 6], ["k", 3]].</li>
                    <li>negaPrefixes ( [string, Decimal][] | string ) An array of pairs of strings and Decimals used as the prefixes for numbers less than 1. The default is [["q", 30], ["r", 27], ["y", 24], ["z", 21], ["a", 18], ["f", 15], ["p", 12], ["n", 9], ["", 6], ["m", 3]]. If this is a string instead of such an array, then the usual prefixes are used, but that string is placed at the start of the prefixes to indicate the use of negative prefixes.</li>
                    <li>frontToBack ( boolean ) If this is false, prefixes are ordered largest to smallest. If this is true, prefixes are ordered smallest to largest. Default is true.</li>
                    <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                    <li>max_in_a_row ( number ) The maximum amount of one prefix in a row. Any more of one prefix in a row than this is truncated: for example, QQQQQQ would become Q[6]. Default is 4.</li>
                    <li>mantissaPower ( Decimal ) Normally, the mantissa number is limited to between 1 and the value of the smallest prefix, which corresponds to the default of 0 mantissaPower. At 1 mantissaPower the bounds are (logBase) and (logBase * smallest prefix), at 2 mantissaPower the bounds are (logBase^2) and (logBase^2 * smallest prefix) and so on. For example, a number represented as 1 M with 0 mantissaPower becomes 1,000 k with 1 mantissaPower.</li>
                    <li>space ( string ) This string is placed between the number and the prefixes. Default is a single space.</li>
                    <li>separator ( string ) This string is placed between each prefix. Default is the empty string.</li>
                    <li>delimiters ( [string, string] ) A pair of strings that determine what goes before and after the number in a truncated expression like Q[6]. Default is ["[", "]"].</li>
                    <li>zero ( string ) The prefix used to represent the 0th prefix. Default is the empty string.</li>
                    <li>mantissaInnerNotation ( Notation ) The notation that the number before the prefixes is notated with. DefaultNotation is the default.</li>
                    <li>exponentInnerNotation ( Notation ) The notation that the number inside a truncated expression is notated with. DefaultNotation is the default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>NestedSINotation</h2>
                <p class="start_hide">A variant of SINotation where the numbers in truncated expressions are themselves notated in this notation. Once the brackets are deep enough, braces are introduced to represent the number of brackets layers.</p>
                <ul class="param_list start_hide">
                    <li>logBase ( Decimal ) The base used by the prefixes. Default is 10.</li>
                    <li>prefixes ( [string, Decimal][] ) An array of pairs of strings and Decimals used as the prefixes. Each pair consists of a prefix (the string) and the value of that prefix as an exponent on logBase (the Decimal). Default is [["Q", 30], ["R", 27], ["Y", 24], ["Z", 21], ["E", 18], ["P", 15], ["T", 12], ["G", 9], ["M", 6], ["k", 3]].</li>
                    <li>negaPrefixes ( [string, Decimal][] | string ) An array of pairs of strings and Decimals used as the prefixes for numbers less than 1. The default is [["q", 30], ["r", 27], ["y", 24], ["z", 21], ["a", 18], ["f", 15], ["p", 12], ["n", 9], ["", 6], ["m", 3]]. If this is a string instead of such an array, then the usual prefixes are used, but that string is placed at the start of the prefixes to indicate the use of negative prefixes.</li>
                    <li>frontToBack ( boolean ) If this is false, prefixes are ordered largest to smallest. If this is true, prefixes are ordered smallest to largest. Default is true.</li>
                    <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                    <li>max_in_a_row ( number ) The maximum amount of one prefix in a row. Any more of one prefix in a row than this is truncated: for example, QQQQQQ would become Q[6]. Default is 4.</li>
                    <li>max_nesting ( number ) The maximum layers of nesting of brackets - any more layers and braces are introduced. Default is 3.</li>
                    <li>mantissaPower ( Decimal ) Normally, the mantissa number is limited to between 1 and the value of the smallest prefix, which corresponds to the default of 0 mantissaPower. At 1 mantissaPower the bounds are (logBase) and (logBase * smallest prefix), at 2 mantissaPower the bounds are (logBase^2) and (logBase^2 * smallest prefix) and so on. For example, a number represented as 1 M with 0 mantissaPower becomes 1,000 k with 1 mantissaPower.</li>
                    <li>hypermantissaPower ( Decimal ) Normally, once braces are introduced, the number represented by the brackets is limited to between (value of the prefix in question) and (value^value), which corresponds to the default of 1 hypermantissaPower. At 0 hypermantissaPower the bounds are 1 and (value), at 2 hypermantissaPower the bounds are (value^value) and (value^^3) and so on. For example, a number represented as Q{5}(10) with 0 hypermantissaPower becomes Q{4}(1 Q[10]) with 0 hypermantissaPower and Q{4}(Q[1 Q[10]]) with 2 mantissaPower.</li>
                    <li>space ( string ) This string is placed between the number and the prefixes. Default is a single space.</li>
                    <li>separator ( string ) This string is placed between each prefix. Default is the empty string.</li>
                    <li>delimiters ( [[string, string], [string, string]] ) An array of two pairs of strings that determine what goes before and after the number in a truncated expression like Q[6]. The first two strings replace brackets, the last two replace braces. Default is [["[", "]"], ["{", "}"]].</li>
                    <li>delimiterPermutation ( number ) The order that the numeral, brackets, and braces go in when multiple are present. Default is 3, which corresponds to [numeral, braces, brackets]. Each value from 0 to 5 represents a different ordering.</li>
                    <li>zero ( string ) The prefix used to represent the 0th prefix. Default is the empty string.</li>
                    <li>innerNotation ( Notation ) The notation that the number before the prefixes is notated with. DefaultNotation is the default.</li>
                    <li>
                        showOnLarge ( [boolean, boolean] ) This parameter shows whether the numeral that the delimiters are placed on is shown - if an entry is true then the numeral and the delimiters are both shown, if it's false then the delimiters and what's inside them are still shown but the numeral they're on is not.
                        showOnLarge[0] is for when brackets are the highest delimiter, showOnLarge[1] is for when braces are the highest delimiter.
                    </li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>HyperSINotation</h2>
                <p class="start_hide">Abbreviates a number using "hyper-SI" prefixes that represent the tetra-powers of 10: 10 is 1 Pl, 100 is 2 Pl, 10^9 is 9 Pl, 10^10 is 1 Dg, 10^100 is 2 Dg, 10^10^9 is 9 Dg, 10^10^10 is 1 Bi, and so on. It's similar to hyperscientific, but with the hyper-exponent replaced by an equivalent prefix abbreviation.</p>
                <ul class="param_list start_hide">
                    <li>slogBase ( Decimal ) The base used by the prefixes. Default is 10.</li>
                    <li>prefixes ( [string, Decimal][] ) An array of pairs of strings and Decimals used as the prefixes. Each pair consists of a prefix (the string) and the value of that prefix as an tetra-exponent on slogBase (the Decimal). Default is [["Dk", 10], ["Tb", 9], ["Co", 8], ["Hc", 7], ["Af", 6], ["Md", 5], ["Sk", 4], ["Bi", 3], ["Dg", 2], ["Pl", 1]].</li>
                    <li>negaPrefixes ( [string, Decimal][] | string ) An array of pairs of strings and Decimals used as the prefixes for numbers less than 1. The default is [["np", 2], ["lg", 1]]. If this is a string instead of such an array, then the usual prefixes are used, but that string is placed at the start of the prefixes to indicate the use of negative prefixes.</li>
                    <li>frontToBack ( boolean ) If this is false, prefixes are ordered largest to smallest. If this is true, prefixes are ordered smallest to largest. Default is true.</li>
                    <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                    <li>max_in_a_row ( number ) The maximum amount of one prefix in a row. Any more of one prefix in a row than this is truncated: for example, DkDkDkDkDkDk would become Dk(6). Default is 4.</li>
                    <li>mantissaPower ( Decimal ) Normally, the mantissa number is limited to between 1 and the value of the smallest prefix, which corresponds to the default of 0 mantissaPower. At 1 mantissaPower the bounds are (slogBase) and (slogBase^smallest prefix), at 2 mantissaPower the bounds are (slogBase^slogBase) and (slogBase^slogBase^smallest prefix) and so on. For example, a number represented as 1 Bi with 0 mantissaPower becomes 10 Dg with 1 mantissaPower and 10,000,000,000 Pl with 2 mantissaPower.</li>
                    <li>space ( string ) This string is placed between the number and the prefixes. Default is a single space.</li>
                    <li>separator ( string ) This string is placed between each prefix. Default is the empty string.</li>
                    <li>delimiters ( [string, string] ) A pair of strings that determine what goes before and after the number in a truncated expression like Dk(6). Default is ["(", ")"].</li>
                    <li>zero ( string ) The prefix used to represent the 0th prefix. Default is the empty string.</li>
                    <li>mantissaInnerNotation ( Notation ) The notation that the number before the prefixes is notated with. DefaultNotation is the default.</li>
                    <li>exponentInnerNotation ( Notation ) The notation that the number inside a truncated expression is notated with. DefaultNotation is the default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>NestedHyperSINotation</h2>
                <p class="start_hide">A variant of HyperSINotation where the numbers in truncated expressions are themselves notated in this notation.</p>
                <ul class="param_list start_hide">
                    <li>slogBase ( Decimal ) The base used by the prefixes. Default is 10.</li>
                    <li>prefixes ( [string, Decimal][] ) An array of pairs of strings and Decimals used as the prefixes. Each pair consists of a prefix (the string) and the value of that prefix as an tetra-exponent on slogBase (the Decimal). Default is [["Dk", 10], ["Tb", 9], ["Co", 8], ["Hc", 7], ["Af", 6], ["Md", 5], ["Sk", 4], ["Bi", 3], ["Dg", 2], ["Pl", 1]].</li>
                    <li>negaPrefixes ( [string, Decimal][] | string ) An array of pairs of strings and Decimals used as the prefixes for numbers less than 1. The default is [["np", 2], ["lg", 1]]. If this is a string instead of such an array, then the usual prefixes are used, but that string is placed at the start of the prefixes to indicate the use of negative prefixes.</li>
                    <li>frontToBack ( boolean ) If this is false, prefixes are ordered largest to smallest. If this is true, prefixes are ordered smallest to largest. Default is true.</li>
                    <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                    <li>max_in_a_row ( number ) The maximum amount of one prefix in a row. Any more of one prefix in a row than this is truncated: for example, DkDkDkDkDkDk would become Dk(6). Default is 4.</li>
                    <li>mantissaPower ( Decimal ) Normally, the mantissa number is limited to between 1 and the value of the smallest prefix, which corresponds to the default of 0 mantissaPower. At 1 mantissaPower the bounds are (slogBase) and (slogBase^smallest prefix), at 2 mantissaPower the bounds are (slogBase^slogBase) and (slogBase^slogBase^smallest prefix) and so on. For example, a number represented as 1 Bi with 0 mantissaPower becomes 10 Dg with 1 mantissaPower and 10,000,000,000 Pl with 2 mantissaPower.</li>
                    <li>space ( string ) This string is placed between the number and the prefixes. Default is a single space.</li>
                    <li>separator ( string ) This string is placed between each prefix. Default is the empty string.</li>
                    <li>delimiters ( [string, string] ) A pair of strings that determine what goes before and after the number in a truncated expression like Dk(6). Default is ["(", ")"].</li>
                    <li>zero ( string ) The prefix used to represent the 0th prefix. Default is the empty string.</li>
                    <li>innerNotation ( Notation ) The notation that the number before the prefixes is notated with. DefaultNotation is the default.</li>
                    <li>showOnLarge ( boolean ) This parameter shows whether the numeral that the delimiters are placed on is shown - if it's true then the numeral and the delimiters are both shown, if it's false then the delimiters and what's inside them are still shown but the numeral they're on is not.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>LetterDigitsNotation</h2>
                <p class="start_hide">
                    Similar to Letters notation, but without a mantissa: the lowercase letters themselves represent the number, so a is 1, b is 2... z is 26, aa is 27... and so on.
                    Uppercase letters mean the same thing they do in Letters notation: in an expression with an uppercase A, the number (which here is represented by the lowercase letters) represent the amount of lowercase letters that would be in the full expression without the A,
                    an uppercase B expression's lowercase letters represent how many lowercase letters would be in an uppercase A expression, and so on.
                </p>
                <ul class="param_list start_hide">
                    <li>letters ( [string[], string[], string[]] ) An array of three arrays of strings. The first array is the lowercase letters, the second array is the uppercase letters, and the third is the "third letters", of which @ is the only one in the default system. The default setting has the 26 lowercase letters as the first array, the 26 uppercase letters as the second array, and a single-entry array containing only @ as the third array.</li>
                    <li>
                        negaLetters ( number | [number, number, number] ) In this notation, the letters are like the digits in an alternate base - this parameter controls how many of the digits in the base are negative. Default is -1, which corresponds to a bijective base. 0 would be a regular base, i.e. including a letter for zero.
                        This parameter must be between -1 and (the amount of letters - 2). If this parameter is a single number, then that's the amount of negative letters for all three letter types, but if it's an array then negaLetters[0] is for the lowercase letters, negaLetters[1] is for the uppercase letters, and negaLetters[2] is for the third letters.
                    </li>
                    <li>max_letters ( number ) The highest amount of letters of a single tier - any more, and they're truncated into the next tier. Default is 9.</li>
                    <li>fraction ( boolean ) If this parameter is false, a non-whole lowercase letter is represented by decimal places. If this parameter is true, a non-whole lowercase letter is represented by an approximation as a "mixed number" fraction. Default is true. Note that if negaLetters[0] is -1 or equal to letters[0].length, an error will be thrown if this parameter is false, as bijective bases don't allow decimal places.</li>
                    <li>
                        placesAbove1 ( number ) If fraction is false, then this is the amount of decimal places shown for numbers above 1. If this is negative, then the absolute value of this parameter is the amount of significant figures shown (though place values before the decimal point are never cut off).
                        On the other hand, if fraction is true, then this is the precision of the fractional approximation. If this is positive, the approximation will be within placesAbove1 of the true value. If this is negative, the approximation will be within value/abs(placesAbove1) of the true value. In other words, a positive precision is absolute, a negative precision is proportional.
                    </li>
                    <li>placesBelow1 ( number ) Same as placesAbove1, but for values below 1 instead.</li>
                    <li>lettersOrder ( number ) The order that the different types of letters go in when multiple are present. Default is 0, which corresponds to [third, uppercase, lowercase]. Each value from 0 to 5 represents a different ordering.</li>
                    <li>commasMin ( Decimal ) Only numbers equal to or greater than this value show commas. If this value is negative, commas are never used. Default is -1.</li>
                    <li>commaSpacing ( number ) How many digits are between each comma? Default is 3.</li>
                    <li>commaChars ( string[] ) What are the commas? If this array of strings has only one character, that character is used as the comma. If the array has multiple characters, the array is cycled through, so commaChars[0] is used for the first comma (the comma closest to the ones place), commaChars[1] is used for the second comma, and repeat, going back to commaChars[0] after the last entry. Default is [","].</li>
                    <li>decimalChar ( string ) The character used as the decimal point. Default is ".".</li>
                    <li>hyperseparator ( string ) This string goes between each tier of letters. Default is the empty string.</li>
                    <li>alwaysHyperseparate ( boolean ) If this parameter is true, hyperseparators appear for every letter tier after the first non-empty one, even if some of the later ones are empty (and thus would normally skip their hyperseparator). Default is false.</li>
                    <li>reverseLetters ( boolean ) If this is true, the letters of a single type are written right to left instead of left to right. Default is false.</li>
                    <li>minnum ( Decimal ) Numbers less than this are written in terms of their reciprocal. Default is 1.</li>
                    <li>recipString ( [string, string] ) The strings used to represent that the letter expression is actually its reciprocal (for numbers below minnum); divisionChar[0] goes before the letter expression, divisionChar[1] goes after the letter expression. Default is ["/", ""].</li>
                    <li>
                        specialLetters ( [[(placeValue : number, fromStart? : number, outerValue? : number) => boolean, string[]][], [(placeValue : number, fromStart? : number, outerValue? : number) => boolean, string[]][], [(placeValue : number, fromStart? : number, outerValue? : number) => boolean, string[]][]] )
                        An array of three arrays of pairs where each pair contains a (number, number?, number?) -> boolean function and a string array; this parameter allows different place values to use different letters (though the amount of letters remains the same). specialLetters[0] is for the lowercase letters, specialLetters[1] is for the uppercase letters, and specialLetters[2] is for the third letters.
                        The function's arguments are the place value of the letter (the last place is place value 0), the letter's distance from the leftmost letter, and the "value" of that letter string (a is 1, z is 26, aa is 27, etc.), and the function returns true if this letter is to use that set of special letters instead of the normal ones; the string array is the set of special letters to be used.
                        Earlier entries in specialLetters take priority, reverting back to the regular letters if none of the special letters apply or if the one that does apply doesn't have enough entries to represent that letter.
                    </li>
                    <li>fixedLetters ( [[number, string][], [number, string][], [number, string][]] ) If the value of the letter string matches any of the numbers in that letter type's array in here (fixedLetters[0] is for the lowercase letters, fixedLetters[1] is for the uppercase letters, fixedLetters[2] is for the third letters), the regular letters are not used - instead, the letter string is just set to that number's corresponding string in this array. Default is [[], [], []], i.e. there are no fixed letters.</li>
                    <li>
                        concatenation ( [null | [boolean, string, string, Notation?], null | [boolean, string, string, Notation?], null | [boolean, string, string, Notation?]] ) concatenation[0] is for lowercase letters, concatenation[1] is for uppercase letters, concatenation[2] is for third letters.
                        If a concatenation entry is not null, then when multiple of the same letter of a single tier are adjacent, they'll be concatenated into a single letter with a number next to it to indicate the amount of that digit that was concatenated.
                        concatenation[n][1] and concatenation[n][2] are placed before and after the concatenation number. If concatenation[n][3] is undefined, the concatenation number is written as a letter string itself, otherwise it's written in whatever notation is given. If concatenation[n][0] is true, then the concatenation number comes after the letter being concatenated, otherwise it comes before.
                        Default is [null, null, null], i.e. no concatenation occurs.
                    </li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>MyriadNotation</h2>
                <p class="start_hide">Uses Donald Knuth's -yllion proposal to abbreviate numbers. In this system, rather than each power of 1,000 getting a new name, each new number name after a hundred is the square of the previous one.</p>
                <ul class="param_list start_hide">
                    <li>dialect ( number ) Controls which set of prefixes is used. Dialect 0 is MathCookie's Standard (the set of prefixes chosen by the creator of eternal_notations), dialect 1 uses the prefixes from Antimatter Dimensions, and dialect 2 is Aarex's Abbreviation System by Aarex Tiaokhiao. Default is 0 (MathCookie's Standard). Any value other than 0, 1, or 2 will default back to 0.</li>
                    <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                    <li>lowestAbbreviated The smallest -yllion that gets abbreviated - numbers below this -yllion are written out in full. Default is 1, i.e. a myllion, i.e. 10^8. Set this to 0 to have a myriad (10^4) get abbreviated too, set this to 2 to make a myllion also be written out but a byllion still be abbreviated, and so on. Do not set this parameter to anything below 0 or higher than 6.</li>
                    <li>entriesLimit ( number ) How many "entries" of a single tier can show up before the notation cuts off with an ellipsis. Default is 6. For example, NNgNeMc-NNgNeMl-NNgNe has 3 entries.</li>
                    <li>charLimit ( number ) How many characters long the abbreviation can be (not including the number at the front, just the -illion prefix) before the notation cuts off with an ellipsis. Default is 100.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. Default is an AlternateBaseNotation that still works in base 10, but used the myriad system's commas instead of the usual commas.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>HypersplitNotation</h2>
                <p class="start_hide">Abbreviates a number by splitting it into hyperoperators like how OmegaNum does, except there's an exponentiation entry between the mantissa and the tetration entry.</p>
                <ul class="param_list start_hide">
                    <li>delimiters ( [string, string][] ) An array of pairs of strings. Each pair of strings is placed around one of the numbers in the split to indicate which hyperoperator it is, with the first string in the pair coming before the number and the second string in the pair coming after the number. delimiters[0] goes with the mantissa, delimiters[1] goes with the exponent, delimiters[2] goes with the tetration, delimiters[3] goes with the pentation. Default is [["", ""], ["*10^", ""], ["((10^)^", ") "], ["((10^^)^", ") "]]. If there are less than four entries, the remaining entries are filled in with empty strings.</li>
                    <li>base ( Decimal ) The base of the exponentiation, tetration, and pentation. Default is 10.</li>
                    <li>maximums ( Decimal | Decimal[] ) The largest allowed values for each operator: anything equal to or above this rolls over to the next operator. maximums[0] is the mantissa limit, maximums[1] is the exponent limit, maximums[2] is the tetration limit. Default is [10, 10, 10]. Setting the mantissa maximum to 0 or either of the other two maximums to 1 (actually, anything less than or equal to its corresponding expMult) will effectively disable that operator: for example, if maximums[1] is 1, then exponentiation is effectively excluded from the operators. If just one Decimal is given rather than an array, all three maximums are the same. If there are less than three entries, the last entry is copied to fill the remaining ones.</li>
                    <li>showZeroes ( number | number[] ) This parameter controls whether hyperoperators in the split with a value of 0 are shown or not. Default is [1, -1, -1, -1], where for each operator, a positive value means it's always shown even if zero, a negative value means it's not shown if it's zero, and a 0 means it's shown when it's zero but only if a higher hyperoperator is nonzero. If only one number is given rather than an array, then the latter three entries all become that value, but the mantissa's showZeroes always defaults to 1 unless you directly change it with an array. If there are less than four entries, the last entry is copied to fill the remaining ones.</li>
                    <li>delimiterPermutation ( number ) The order that the hyperoperators go in when multiple are present. The default is 1, which corresponds to [pentation, tetration, mantissa, exponent]. Each value from 0 to 23 represents a different ordering.</li>
                    <li>originalMaximums ( Decimal | Decimal[] ) These are the maximums that apply when the next operator is 0: for example, if maximums is [10, 10, 10] but originalMaximums is [100, 10, 10], then the mantissa can go up to 100 before exponents begin but once the exponent has begun increasing then the mantissa is limited to 10 (this applies even if tetration or pentation is above 0, as long as exponent is still 0). Is the same as maximums by default.</li>
                    <li>minnum ( Decimal ) Values above this and below maximums[0] will just return [value, 0, 0, 0] instead of doing any splitting; this prevents small-but-not-too-small values like 2 from forcing negative exponents. Default is 1. Set this value to a negative number to disable this functionality.</li>
                    <li>mantissaRounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                    <li>innerNotations ( Notation | Notations[] ) The notations that the numbers are themselves notated with. Has up to four entries, corresponding to the mantissa, exponent, tetration, and pentation in that order. The default is for DefaultNotation to be used for all four. If this is just a single Notation instead of an array, all four hyperoperators use the same innerNotation. If there are less than four entries, the last entry is copied to fill the remaining ones.</li>
                    <li>engineerings ( Decimal | [Decimal | Decimal[], Decimal | Decimal[], Decimal | Decimal[]] ) An array of three arrays of Decimals, each of which may potentially be just a single Decimal instead of an array of them. These behave like the engineerings parameter in other notations; the first entry is for exponentiation, the second is for tetration, the third is for pentation. You may make this a single Decimal instead of an array at all to give all three the same single engineering value, but you can't make a single array to give to all three because an array of single Decimals uses "different single values for each of the three hyperoperators" rather than "the same array for all three hyperoperators"... in other words, if you use an array, the upper-level array needs to have three entries, one for each non-mantissa hyperoperator in the split, and each entry of this three-entry array behaves as an engineerings parameter. Default is [[1], [1], [1]], and if less than three entries are provided, the remaining ones are set to [1].</li>
                    <li>expMultipliers ( Decimal | Decimal[] ) An array of up to three Decimals which multiply the exponent, tetration, and pentation respectively; this multiplication happens once to start and one more time between each application of the next hyperoperator. Default is [1, 1, 1]. If just one Decimal is given rather than an array, all three multipliers are the same. If there are less than three entries, the remaining ones are set to 1.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>FactorialNotation</h2>
                <p class="start_hide">Represents numbers in terms of factorials, so 24 is "4!" and 720 is "6!".</p>
                <ul class="param_list start_hide">
                    <li>iterations ( number ) The amount of factorial iterations: 1 is factorial notation, 2 is double factorial (as in (x!)!, not the other meaning of "multifactorial"), and so on. This can be negative: with -1 iterations, 4 would be "24".</li>
                    <li>max_in_a_row ( number ) If the there are more !'s than this, those !'s are made into a !n expression. Default is 5.</li>
                    <li>factorialChars ( [[string, string], [string, string], [string, string]] ) An array of three pairs of strings that are used as the factorial characters. In each pair, the first entry goes before the number, the second entry goes after the number. factorialChars[0] takes the place of the ! in "6!", factorialChars[1] takes the place of the second ! in "25!!" (factorialChars[0] is for the innermost factorial, factorialChars[1] is for the outer ones), and factorialChars[2] takes the place of the ! in 45!7. Default is [["", "!"], ["", "!"], ["!", ""]].</li>
                    <li>inverseChars ( [[string, string], [string, string], [string, string]] | null ) An equivalent of inverseChars used for a factorial of negative iterations. Default is [["", ""], ["", ""], ["", ""]]. If this is set to null instead of a pair of strings, negative iterations just show negative iterations of factorialChars[2], such as !-1.</li>
                    <li>superexpAfter ( boolean ) This is true by default; if it's true, an !n expression comes after the number instead of before.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. DefaultNotation is the default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the number in an !n expression is itself notated with. Is the same as innerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>MultiFactorialNotation</h2>
                <p class="start_hide">A variant of factorial notation that uses a different amount of factorial iterations depending on how large the number is.</p>
                <ul class="param_list start_hide">
                    <li>maxnum ( Decimal ) Only numbers below this value are allowed to show up on their own - anything higher and the amount of iterations increases. Default is 3628800, i.e. 10!.</li>
                    <li>max_in_a_row ( number ) If the there are more !'s than this, those !'s are made into a !n expression. Default is 5.</li>
                    <li>minIterations ( number ) The minimum amount of factorial iterations. Default is 1.</li>
                    <li>engineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed iteration amounts: if it's three then the amount of iterations will always be a multiple of 3. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted iteration amounts are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0).</li>
                    <li>factorialChars ( [[string, string], [string, string], [string, string]] ) An array of three pairs of strings that are used as the factorial characters. In each pair, the first entry goes before the number, the second entry goes after the number. factorialChars[0] takes the place of the ! in "6!", factorialChars[1] takes the place of the second ! in "25!!" (factorialChars[0] is for the innermost factorial, factorialChars[1] is for the outer ones), and factorialChars[2] takes the place of the ! in 45!7. Default is [["", "!"], ["", "!"], ["!", ""]].</li>
                    <li>inverseChars ( [[string, string], [string, string], [string, string]] | null ) An equivalent of inverseChars used for a factorial of negative iterations. Default is [["", ""], ["", ""], ["", ""]]. If this is set to null instead of a pair of strings, negative iterations just show negative iterations of factorialChars[2], such as !-1.</li>
                    <li>superexpAfter ( boolean ) This is true by default; if it's true, an !n expression comes after the number instead of before.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. DefaultNotation is the default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the number in an !n expression is itself notated with. Is the same as innerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>FactorialAmountNotation</h2>
                <p class="start_hide">Abbreviates numbers in terms of how many times you'd have to apply factorial to 3 to get to them, so 3 is 3!0, 6 is 3!1, and 720 is 3!2.</p>
                <ul class="param_list start_hide">
                    <li>iterations ( number ) The amount of factorial-amount iterations.</li>
                    <li>max_in_a_row ( number ) If there would be more 3!'s in the expression than this, those 3!'s are made into a (3!^n) expression. Default is 5.</li>
                    <li>base ( Decimal ) The value the repeated factorials are applied to. Default is 3.</li>
                    <li>factorialChars ( [[string, string], [string, string], [string, string]] ) An array of three pairs of strings that are used as the characters to indicate factorial amount notation. In each pair, the first entry goes before the number, the second entry goes after the number. factorialChars[0] takes the place of the ! in "2.5!6", factorialChars[1] takes the place of the second ! in "3!5!8" (factorialChars[0] is for the innermost factorial, factorialChars[1] is for the outer ones), and factorialChars[2] takes the place of the (!^) in 3(!^10)4. Default is [["!", ""], ["!", ""], ["(!^", ")"]].</li>
                    <li>inverseChars ( [[string, string], [string, string], [string, string]] | null ) An equivalent of factorialChars used for a factorial amount of negative iterations. Default is [["", ""], ["", ""], ["(^", ")"]]. If this is set to null instead of a pair of strings, negative iterations just show negative powers of factorialChars[2], such as !^-1.</li>
                    <li>superexpAfter ( boolean ) This is false by default; if it's true, a (!^n) expression comes after the number instead of before.</li>
                    <li>baseShown ( number ) This is 0 by default. If this is 0, the base is not shown. If this is positive, the base is shown at the beginning of the expression. If this is negative, the base is shown at the end of the expression.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. DefaultNotation is the default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the number in a (!^n) expression is itself notated with. Is the same as innerNotation by default.</li>
                    <li>baseInnerNotation ( Notation ) The notation that the base within the expression, if included, is itself notated with. Is the same as innerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>MultiFactorialAmountNotation</h2>
                <p class="start_hide">A variant of factorial amount notation that uses a different amount of iterations depending on how large the number is.</p>
                <ul class="param_list start_hide">
                    <li>maxnum ( Decimal ) Only numbers below this value are allowed to show up on their own - anything higher and the amount of iterations increases. Default is 1e10.</li>
                    <li>max_in_a_row ( number ) If there would be more 3!'s in the expression than this, those 3!'s are made into a (3!^n) expression. Default is 5.</li>
                    <li>minIterations ( number ) The minimum amount of logarithm iterations. Default is 1.</li>
                    <li>base ( Decimal ) The value the repeated factorials are applied to. Default is 3.</li>
                    <li>engineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed iteration amounts: if it's three then the amount of iterations will always be a multiple of 3. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted iteration amounts are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0).</li>
                    <li>factorialChars ( [[string, string], [string, string], [string, string]] ) An array of three pairs of strings that are used as the characters to indicate factorial amount notation. In each pair, the first entry goes before the number, the second entry goes after the number. factorialChars[0] takes the place of the ! in "2.5!6", factorialChars[1] takes the place of the second ! in "3!5!8" (factorialChars[0] is for the innermost factorial, factorialChars[1] is for the outer ones), and factorialChars[2] takes the place of the (!^) in 3(!^10)4. Default is [["!", ""], ["!", ""], ["(!^", ")"]].</li>
                    <li>inverseChars ( [[string, string], [string, string], [string, string]] | null ) An equivalent of factorialChars used for a factorial amount of negative iterations. Default is [["", ""], ["", ""], ["(^", ")"]]. If this is set to null instead of a pair of strings, negative iterations just show negative powers of factorialChars[2], such as !^-1.</li>
                    <li>superexpAfter ( boolean ) This is false by default; if it's true, a (!^n) expression comes after the number instead of before.</li>
                    <li>baseShown ( number ) This is 0 by default. If this is 0, the base is not shown. If this is positive, the base is shown at the beginning of the expression. If this is negative, the base is shown at the end of the expression.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. DefaultNotation is the default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the number in a (!^n) expression is itself notated with. Is the same as innerNotation by default.</li>
                    <li>baseInnerNotation ( Notation ) The notation that the base within the expression, if included, is itself notated with. Is the same as innerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>FactorialScientificNotation</h2>
                <p class="start_hide">Like scientific notation, but with factorials instead of exponents. Abbreviates 12 as "2 * 3!" and 16! as "1 * 16!". For larger numbers, switches to abbreviations like "(8 * 17!)!" and eventually "(!5)5.6 * 7!", the latter of which means "start with 5.6 * 7! and take the factorial of it 5 times".</p>
                <ul class="param_list start_hide">
                    <li>maxnum ( Decimal ) Only factorials below this value are allowed - anything higher and the factorial number itself is abbreviated in factorial-scientific notation. Default is 3628800.</li>
                    <li>max_es_in_a_row ( number ) If the factorial representation would have more !'s at the end than this, those !'s are made into an !n expression. Default is 5.</li>
                    <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                    <li>engineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed factorial values: if it's three then the factorial will always be a multiple of 3. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted factorial values are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0).</li>
                    <li>mantissaPower ( Decimal ) Normally, the mantissa in scientific notation is bounded by 1 and (exponent + 1), which corresponds to the default mantissaPower of 0. If mantissaPower is 1, the bounds are (exponent + 1) and (exponent + 1)*(exponent + 2), if mantissaPower is 2 then the bounds are (exponent)*(exponent + 1) and (exponent)*(exponent + 1)*(exponent + 2), and so on. For example, 15!, which normally returns [1, 15], would become [15, 14] with 1 mantissaPower and [210, 13] with 2 mantissaPower.</li>
                    <li>iteration_zero ( boolean ) If this is true, then numbers less than maxnum will ignore the scientific notation and jump directly to the innerNotation - useful if you want 1 to just be abbreviated as "1" instead of "1 * 1!". Default is false.</li>
                    <li>expChars ( [[string, string], [string | boolean, string | boolean], [string, string]] ) An array of three pairs of strings that are used as the between characters for scientific notation. In each pair, the first entry goes before the exponent, the second entry goes after the exponent. expChars[0] takes the place of the * and ! in "4 * 14!", expChars[1] takes the place of the ()! in "(7.5 * 11!)!", and expChars[2] takes the place of the ! in 7!9. If expChars[1][0] is a boolean instead of a string: if it's false, then expChars[1][0] is set to be expChars[0][0] with the way mantissaInnerNotation formats 1 tacked on the beginning, and if it's true than the 1 is tacked on the end instead. Likewise for expChars[1][1] (expChars[0][1] with a 1 on it). Default is [[" * ", "!"], ["(", ")!"], ["(!", ")"]].</li>
                    <li>negExpChars ( null | [[string, string] | boolean, [string, string]] ) This can either be null or a pair of pairs of strings (in which the first pair of strings may be a boolean instead). Ignore this parameter if it's null. If it's a pair of pairs of strings, then the first pair is used like expChars[0] but for negative exponents (so if it's ["d", ""], then 2e-4 would be 2d4 instead), and the second pair is used on small numbers whose reciprocals are large enough to need expChars[1], in which case the second pair indicates that a reciprocal has been taken. If negExpChars[0] is a boolean instead, then if it's true the notation goes directly to the reciprocal behavior for all inputs less than 1, while if it's false then single-iteration inputs don't use negExpChars but multi-iteration ones still use reciprocal behavior. Default is [[" / ", "!"], ["1 / ", ""]].</li>
                    <li>expBefore ( boolean ) If this parameter is true, the exponent comes before the mantissa instead of after. Default is false.</li>
                    <li>superexpAfter ( boolean ) If this parameter is true, (e^n) expressions come after the rest of the number instead of before. Default is true.</li>
                    <li>mantissaInnerNotation ( Notation ) The notation that the numbers within the mantissas are themselves notated with. DefaultNotation is the default.</li>
                    <li>exponentInnerNotation ( Notation ) The notation that the highest factorial is itself notated with. Is the same as mantissaInnerNotation by default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the number in an (!n) expression is itself notated with. Is the same as exponentInnerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>FactorialScientificIterationsNotation</h2>
                <p class="start_hide">This notation performs factorial-scientific notation a certain number of times. 1 iteration means the number is in the form A * B! (where A and B are abbreviated using the innerNotation), 2 iterations means the number is in the form A * (B * C!)!, and so on.</p>
                <ul class="param_list start_hide">
                    <li>iterations ( number ! ) The amount of iterations.</li>
                    <li>max_es_in_a_row ( number ) If the factorial representation would have more !'s at the end than this, those !'s are made into an !n expression. Default is 5.</li>
                    <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                    <li>engineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed factorial values: if it's three then the factorial will always be a multiple of 3. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted factorial values are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0).</li>
                    <li>mantissaPower ( Decimal ) Normally, the mantissa in scientific notation is bounded by 1 and (exponent + 1), which corresponds to the default mantissaPower of 0. If mantissaPower is 1, the bounds are (exponent + 1) and (exponent + 1)*(exponent + 2), if mantissaPower is 2 then the bounds are (exponent)*(exponent + 1) and (exponent)*(exponent + 1)*(exponent + 2), and so on. For example, 15!, which normally returns [1, 15], would become [15, 14] with 1 mantissaPower and [210, 13] with 2 mantissaPower.</li>
                    <li>expChars ( [[string, string], [string | boolean, string | boolean], [string, string]] ) An array of three pairs of strings that are used as the between characters for scientific notation. In each pair, the first entry goes before the exponent, the second entry goes after the exponent. expChars[0] takes the place of the * and ! in "4 * 14!", expChars[1] takes the place of the ()! in "(7.5 * 11!)!", and expChars[2] takes the place of the ! in 7!9. If expChars[1][0] is a boolean instead of a string: if it's false, then expChars[1][0] is set to be expChars[0][0] with the way mantissaInnerNotation formats 1 tacked on the beginning, and if it's true than the 1 is tacked on the end instead. Likewise for expChars[1][1] (expChars[0][1] with a 1 on it). Default is [[" * ", "!"], ["(", ")!"], ["(!", ")"]].</li>
                    <li>negExpChars ( null | [[string, string] | boolean, [string, string]] ) This can either be null or a pair of pairs of strings (in which the first pair of strings may be a boolean instead). Ignore this parameter if it's null. If it's a pair of pairs of strings, then the first pair is used like expChars[0] but for negative exponents (so if it's ["d", ""], then 2e-4 would be 2d4 instead), and the second pair is used on small numbers whose reciprocals are large enough to need expChars[1], in which case the second pair indicates that a reciprocal has been taken. If negExpChars[0] is a boolean instead, then if it's true the notation goes directly to the reciprocal behavior for all inputs less than 1, while if it's false then single-iteration inputs don't use negExpChars but multi-iteration ones still use reciprocal behavior. Default is [[" / (", ")!"], ["1 / ", ""]].</li>
                    <li>expBefore ( boolean ) If this parameter is true, the exponent comes before the mantissa instead of after. Default is false.</li>
                    <li>superexpAfter ( boolean ) If this parameter is true, (e^n) expressions come after the rest of the number instead of before. Default is true.</li>
                    <li>mantissaInnerNotation ( Notation ) The notation that the numbers within the mantissas are themselves notated with. DefaultNotation is the default.</li>
                    <li>exponentInnerNotation ( Notation ) The notation that the highest factorial is itself notated with. Is the same as mantissaInnerNotation by default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the number in an (!n) expression is itself notated with. Is the same as exponentInnerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>FactorialHyperscientificNotation</h2>
                <p class="start_hide">Like hyperscientific notation, but with repeated factorials instead of tetration. For example, 6 (3!) could be 3!1, 4!2 means 4!! (which is around 6.2e23), and 7!20 means 7!!!!!!... with 20 !'s.</p>
                <ul class="param_list start_hide">
                    <li>maxnum ( Decimal ) Only factorials below this value are allowed - anything higher and the factorial number itself is abbreviated in factorial-hyperscientific notation. Default is 3628800.</li>
                    <li>max_Fs_in_a_row ( number ) If the representation would have more layers of !'s at the end than this, those !'s are made into an (!^n) expression. Default is 5.</li>
                    <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                    <li>engineerings ( Decimal | DecimalSource[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed factorial amount values: if it's three then the factorial amount will always be a multiple of 3. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted factorial amount values are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0).</li>
                    <li>limit ( Decimal ) If the mantissa is equal to or above the limit, another factorial is taken to bring the mantissa back above the limit. Default is 3.</li>
                    <li>iteration_zero ( boolean ) If this is true, then numbers less than maxnum will ignore the scientific notation and jump directly to the innerNotation - useful if you want 6 to just be abbreviated as "6" instead of "3!1". Default is false.</li>
                    <li>expChars ( [[string, string], [string | boolean, string | boolean], [string, string]] ) An array of three pairs of strings that are used as the between characters for scientific notation. In each pair, the first entry goes before the factorial amount, the second entry goes after the factorial amount. expChars[0] takes the place of the ! in "3!4", expChars[1] takes the place of the 3! in "3!5!7!", and expChars[2] takes the place of the (!^ and ) in (!^5)4!7. If expChars[1][0] is a boolean instead of a string: if it's false, then expChars[1][0] is set to be expChars[0][0] with the way mantissaInnerNotation formats the limit tacked on the beginning, and if it's true than the limit string is tacked on the end instead. Likewise for expChars[1][1] (expChars[0][1] with a 'l' on it, where 'l' is however the limit is formatted in mantissaInnerNotation). Default is [["!", ""], [false, ""], ["(!^", ")"]].</li>
                    <li>negExpChars ( null | [[string, string] | boolean, [string, string]] ) This can either be null or a pair of pairs of strings (in which the first pair of strings may be a boolean instead). Ignore this parameter if it's null, which is the default. If it's a pair of pairs of strings, then the first pair is used like expChars[0] but for negative exponents (so if it's ["d", ""], then 2e-4 would be 2d4 instead), and the second pair is used on small numbers whose reciprocals are large enough to need expChars[1], in which case the second pair indicates that a reciprocal has been taken. If negExpChars[0] is a boolean instead, then if it's true the notation goes directly to the reciprocal behavior for all inputs less than 1, while if it's false then single-iteration inputs don't use negExpChars but multi-iteration ones still use reciprocal behavior.</li>
                    <li>expBefore ( boolean ) If this parameter is true, the factorial amount comes before the mantissa instead of after. Default is false.</li>
                    <li>superexpAfter ( boolean ) If this parameter is true, (e^n) expressions come after the rest of the number instead of before. Default is false.</li>
                    <li>mantissaInnerNotation ( Notation ) The notation that the numbers within the mantissas are themselves notated with. DefaultNotation is the default.</li>
                    <li>exponentInnerNotation ( Notation ) The notation that the highest factorial is itself notated with. Is the same as mantissaInnerNotation by default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the number in an (!^n) expression is itself notated with. Is the same as exponentInnerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>FactorialHyperscientificIterationsNotation</h2>
                <p class="start_hide">This notation performs factorial-hyperscientific notation a certain number of times. 1 iteration means the number is in the form A!B (where A and B are abbreviated using the innerNotation), 2 iterations means the number is in the form A!B!C, and so on.</p>
                <ul class="param_list start_hide">
                    <li>maxnum ( number ! ) The amount of iterations.</li>
                    <li>max_Fs_in_a_row ( number ) If the representation would have more layers of !'s at the end than this, those !'s are made into an (!^n) expression. Default is 5.</li>
                    <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                    <li>engineerings ( Decimal | DecimalSource[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed factorial amount values: if it's three then the factorial amount will always be a multiple of 3. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted factorial amount values are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0).</li>
                    <li>limit ( Decimal ) If the mantissa is equal to or above the limit, another factorial is taken to bring the mantissa back above the limit. Default is 3.</li>
                    <li>expChars ( [[string, string], [string | boolean, string | boolean], [string, string]] ) An array of three pairs of strings that are used as the between characters for scientific notation. In each pair, the first entry goes before the factorial amount, the second entry goes after the factorial amount. expChars[0] takes the place of the ! in "3!4", expChars[1] takes the place of the 3! in "3!5!7!", and expChars[2] takes the place of the (!^ and ) in (!^5)4!7. If expChars[1][0] is a boolean instead of a string: if it's false, then expChars[1][0] is set to be expChars[0][0] with the way mantissaInnerNotation formats the limit tacked on the beginning, and if it's true than the limit string is tacked on the end instead. Likewise for expChars[1][1] (expChars[0][1] with a 'l' on it, where 'l' is however the limit is formatted in mantissaInnerNotation). Default is [["!", ""], [false, ""], ["(!^", ")"]].</li>
                    <li>negExpChars ( null | [[string, string] | boolean, [string, string]] ) This can either be null or a pair of pairs of strings (in which the first pair of strings may be a boolean instead). Ignore this parameter if it's null, which is the default. If it's a pair of pairs of strings, then the first pair is used like expChars[0] but for negative exponents (so if it's ["d", ""], then 2e-4 would be 2d4 instead), and the second pair is used on small numbers whose reciprocals are large enough to need expChars[1], in which case the second pair indicates that a reciprocal has been taken. If negExpChars[0] is a boolean instead, then if it's true the notation goes directly to the reciprocal behavior for all inputs less than 1, while if it's false then single-iteration inputs don't use negExpChars but multi-iteration ones still use reciprocal behavior.</li>
                    <li>expBefore ( boolean ) If this parameter is true, the factorial amount comes before the mantissa instead of after. Default is false.</li>
                    <li>superexpAfter ( boolean ) If this parameter is true, (e^n) expressions come after the rest of the number instead of before. Default is false.</li>
                    <li>mantissaInnerNotation ( Notation ) The notation that the numbers within the mantissas are themselves notated with. DefaultNotation is the default.</li>
                    <li>exponentInnerNotation ( Notation ) The notation that the highest factorial is itself notated with. Is the same as mantissaInnerNotation by default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the number in an (!^n) expression is itself notated with. Is the same as exponentInnerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>FactoradicNotation</h2>
                <p class="start_hide">Abbreviates a given number in the "factoradic base", where the place values are the factorial numbers, which means each digit can go one value higher than the previous. Behaves like AlternateBaseNotation for larger numbers, but with factorials instead of powers.</p>
                <ul class="param_list start_hide">
                    <li>digitList ( string[] ) An array of strings taken as the digits of the base. Default is the default 64 digits: 0-9, then A-Z, then a-z, then +, then /.</li>
                    <li>hyperBase ( Decimal ) The base used for the hyperscientific stage of the notation. Default is 720.</li>
                    <li>placesAbove1 ( number ) For numbers above 1, this is the amount of decimal places shown. If this is negative, then the absolute value of this parameter is the amount of significant figures shown (though place values before the decimal point are never cut off). Default is -4.</li>
                    <li>placesBelow1 ( number ) For numbers below 1, this is the amount of decimal places shown. If this is negative, then the absolute value of this parameter is the amount of significant figures shown (though place values before the decimal point are never cut off). Default is -4.</li>
                    <li>commasMin ( Decimal ) Only numbers equal to or greater than this value show commas. Default is 0, which means commas are always shown. If this value is negative, commas are never used.</li>
                    <li>maxnum ( Decimal ) Numbers greater than or equal to this are converted into scientific notation. Default is 1307674368000 (15!).</li>
                    <li>minnum ( Decimal ) Numbers less than this are converted into scientific notation. Default is 1 / 362880 (1 / 9!).</li>
                    <li>max_exps_in_a_row ( number ) If the scientific representation would have more "exponential characters" (Which defaults to $) than this, switches to the hyperscientific stage of the notation. Default is 5.</li>
                    <li>mantissaPower ( Decimal ) Normally, the mantissa in factorial-scientific notation is bounded by 1 and (exponent + 1), which corresponds to the default mantissaPower of 0. If mantissaPower is 1, the bounds are (exponent + 1) and (exponent + 1)*(exponent + 2), if mantissaPower is 2 then the bounds are (exponent)*(exponent + 1) and (exponent)*(exponent + 1)*(exponent + 2), and so on. For example, a number normally represented as "1$15", would become "15$14" with 1 mantissaPower and "210$13" with 2 mantissaPower.</li>
                    <li>showZeroes ( number ) A positive, zero, or negative number. If this is positive, all the decimal places up to (places) are shown, even if some of them are zeroes at the end. If this is zero, all the decimal places up to (places) are shown, even if some are zeroes at the end, but only if not all of the decimal places are zero. If this negative, zeroes at the end of the decimal places are not shown. Default is -1.</li>
                    <li>reverseDigits ( boolean ) If this parameter is true, digits are written right-to-left instead of left-to-right. Default is false.</li>
                    <li>commaSpacing ( number ) How many digits are between each comma? Default is 3.</li>
                    <li>commaChars ( string[] ) What are the commas? If this array of strings has only one character, that character is used as the comma. If the array has multiple characters, the array is cycled through, so commaChars[0] is used for the first comma (the comma closest to the ones place), commaChars[1] is used for the second comma, and repeat, going back to commaChars[0] after the last entry. Default is [","].</li>
                    <li>decimalChar ( string ) The character used as the decimal point. Default is ".".</li>
                    <li>expChars ( [[string, string], [string | boolean, string | boolean], [string, string], [string | boolean, string | boolean]] ) An array of four pairs of strings that are used as the between characters for scientific notation. In each pair, the first entry goes before the exponent, the second entry goes after the exponent. expChars[0] takes the place of the e in "1e10", expChars[1] takes the place of the first e in "e1e10", expChars[2] takes the place of the F in "1F10", and expChars[3] takes the place of the F in "F1e10". If expChars[1][0] is a boolean instead of a string: if it's false, then expChars[1][0] is set to be expChars[0][0] with the way this notation formats 1 tacked on the beginning, and if it's true than the 1 is tacked on the end instead. Likewise for expChars[1][1] (expChars[0][1] with a 1 on it), expChars[3][0] (expChars[2][0] with a 'b' on it, where 'b' is however hyperBase is formatted in this notation), and expChars[3][1] (expChars[2][1] with a 'b' on it, where 'b' is however hyperBase is formatted in this notation). Default is [["$", ""], [false, ""], ["!", ""], [false, ""]].</li>
                    <li>negExpChars ( null | [[string, string] | boolean, [string, string]] ) This can either be null or a pair of pairs of strings (in which the first pair of strings may be a boolean instead). Ignore this parameter if it's null. If it's a pair of pairs of strings, then the first pair is used like expChars[0] but for negative exponents (so if it's ["d", ""], then 2e-4 would be 2d4 instead), and the second pair is used on small numbers whose reciprocals are large enough to need expChars[1], in which case the second pair indicates that a reciprocal has been taken. If negExpChars[0] is a boolean instead, then if it's true the notation goes directly to the reciprocal behavior for all inputs less than 1, while if it's false then single-iteration inputs don't use negExpChars but multi-iteration ones still use reciprocal behavior. Default is [true, "1 / "], where that 1 is replaced with whatever digitList[1] is.</li>
                    <li>expBefore ( boolean ) If this parameter is true, the exponent comes before the mantissa instead of after. Default is false.</li>
                    <li>hyperexpBefore ( boolean ) If this parameter is true, the hyperexponent comes before the mantissa instead of after. Default is false.</li>
                    <li>precision ( number ) How many digits are actually calculated before the remaining ones are just set to 0; this parameter exists so the notation doesn't bother displaying meaningless digits beyond the limit of floating point precision. Default is 18.</li>
                    <li>
                        specialDigits ( [(placeValue : number, fromStart? : number, outerValue? : number) => boolean, string[]][] ) An array of pairs where each pair contains a (number, number?, number?) -> boolean function and a string array; this parameter allows different place values to use different digits.
                        The function's arguments are the place value of the digit (the ones place is place value 0), the digit's distance from the leftmost digit, and the value being inputted, and the function returns true if this digit is to use that set of special digits instead of the normal ones; the string array is the set of special digits to be used.
                        Earlier entries in specialDigits take priority, reverting back to the digits from base if none of the special digits apply or if the one that does apply doesn't have enough entries to represent that digit.
                    </li>
                    <li>
                        concatenation ( null | [boolean, string, string, Notation?] ) If this parameter is not null, then when multiple of the same digit are adjacent, they'll be concatenated into a single digit with a number next to it to indicate the amount of that digit that was concatenated.
                        concatenation[1] and concatenation[2] are placed before and after the concatenation number. If concatenation[3] is undefined, the concatenation number is written in the alternate base itself, otherwise it's written in whatever notation is given. If concatenation[0] is true, then the concatenation number comes after the digit being concatenated, otherwise it comes before.
                        Default is null, i.e. no concatenation occurs.
                    </li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>RootNotation</h2>
                <p class="start_hide">Abbreviates numbers in terms of a root; this is the square root by default, so 64 is 8^2 and 10,000 is 100^2.</p>
                <ul class="param_list start_hide">
                    <li>height ( Decimal ) The height of the root. Default is 2.</li>
                    <li>iterations ( Decimal ) The amount of root iterations: 1 is regular Root notation, 2 means the root is taken twice, and so on. This can be negative: for example, with -1 iterations, 13 would be "(169)"</li>
                    <li>max_in_a_row ( number ) If there are more root iterations than this, then the ^b's are made into a ^b^n expression. Default is 5.</li>
                    <li>rootChars ( [[string, string], [string, string], [string, string] | null] ) An array of three pairs of strings that are used as the characters to indicate root notation. In each pair, the first entry goes before the number, the second entry goes after the number. rootChars[0] takes the place of the ^ in "5^2", rootChars[1] takes the place of the ( and )^ in "(7^2)^2^2" (rootChars[0] is for the innermost root, rootChars[1] is for the outer ones), and rootChars[2] takes the place of the ^2^13 in 7^2^13. Default is [["", "^"], ["", "^"], null]; if rootChars[2] is null, then it's set to ["^(base)^", ""].</li>
                    <li>inverseChars ( [[string, string], [string, string], [string, string] | null] | null ) An equivalent of rootChars used for a root of negative iterations. Default is [["(", ")"], ["(", ")"], null]. If this is set to null instead of a pair of strings, negative iterations just show negative iterations of rootChars[2], such as ^2^-1.</li>
                    <li>superexpAfter ( boolean ) This is true by default; if it's true, a ^b^n expression comes after the number instead of before.</li>
                    <li>heightShown ( number ) This is -1 by default. If this is 0, the height is not shown. If this is positive, the height is shown at the beginning of the expression. If this is negative, the height is shown at the end of the expression. The height is not shown once the root is made into a ^b^n expression unless the absolute value of this parameter is above 1.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. DefaultNotation is the default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the n in an (^b^n) expression is itself notated with. Is the same as innerNotation by default.</li>
                    <li>heightInnerNotation ( Notation ) The notation that the height within the expression, if included, is itself notated with. Is the same as innerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>IncreasingRootNotation</h2>
                <p class="start_hide">A variant of root notation that uses a different root height depending on how large the number is.</p>
                <ul class="param_list start_hide">
                    <li>maxnum ( Decimal ) Only numbers below this value are allowed to show up on their own - anything higher and the height increases. Default is 10000.</li>
                    <li>minHeight ( Decimal ) The minimum root height. Default is 2.</li>
                    <li>engineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed height values: if it's three then the height will always be a multiple of 3. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted height values are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0).</li>
                    <li>rootChars ( [[string, string], [string, string], [string, string] | null] ) An array of three pairs of strings that are used as the characters to indicate root notation. In each pair, the first entry goes before the number, the second entry goes after the number. rootChars[0] takes the place of the ^ in "5^2", rootChars[1] takes the place of the ( and )^ in "(7^2)^2^2" (rootChars[0] is for the innermost root, rootChars[1] is for the outer ones), and rootChars[2] takes the place of the ^2^13 in 7^2^13. Default is [["", "^"], ["", "^"], null]; if rootChars[2] is null, then it's set to ["^(base)^", ""].</li>
                    <li>inverseChars ( [[string, string], [string, string], [string, string] | null] | null ) An equivalent of rootChars used for a root of negative iterations. Default is [["(", ")"], ["(", ")"], null]. If this is set to null instead of a pair of strings, negative iterations just show negative iterations of rootChars[2], such as ^2^-1.</li>
                    <li>heightShown ( number ) This is -1 by default. If this is 0, the height is not shown. If this is positive, the height is shown at the beginning of the expression. If this is negative, the height is shown at the end of the expression. The height is not shown once the root is made into a ^b^n expression unless the absolute value of this parameter is above 1.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. DefaultNotation is the default.</li>
                    <li>heightInnerNotation ( Notation ) The notation that the height within the expression, if included, is itself notated with. Is the same as innerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>MultiRootNotation</h2>
                <p class="start_hide">A variant of root notation that uses a different amount of root iterations depending on how large the number is. Once the amount of iterations gets too high, we go to a higher layer where the amount of iterations is itself written in this notation, and repeat that layering process for larger and larger numbers.</p>
                <ul class="param_list start_hide">
                    <li>height ( Decimal ) The height of the root. Default is 2.</li>
                    <li>maxnum ( Decimal ) Only numbers below this value are allowed to show up on their own - anything higher and the height increases. Default is 10000.</li>
                    <li>max_iterations_in_a_row ( number ) If there are more root iterations than this, then the ^b's are made into a ^b^n expression. Default is 5.</li>
                    <li>minIterations ( Decimal ) The minimum amount of root iterations. Default is 1.</li>
                    <li>maxIterations ( Decimal ) The amount of root iterations must be less than this: anything higher and the layer is increased. Default is 10000.</li>
                    <li>layerBase ( Decimal ) The number that we're repeatedly taking the root of on higher layers. Default is equal to the height so that the power tower is filled with one number instead of two alternating numbers.</li>
                    <li>max_layers_in_a_row ( number ) If there are more root iterations than this, then the ^b^h's are made into a (^b^h)^n expression. Default is 3.</li>
                    <li>iterationEngineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed amounts of iterations: if it's three then the iteration amount will always be a multiple of 3. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted iteration amount values are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0).</li>
                    <li>layerEngineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed amounts of layers: if it's three then the layer amount will always be a multiple of 3. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted layer amount values are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0).</li>
                    <li>rootChars ( [[string, string], [string, string], [string, string] | null] ) An array of three pairs of strings that are used as the characters to indicate root notation. In each pair, the first entry goes before the number, the second entry goes after the number. rootChars[0] takes the place of the ^ in "5^2", rootChars[1] takes the place of the ( and )^ in "(7^2)^2^2" (rootChars[0] is for the innermost root, rootChars[1] is for the outer ones), and rootChars[2] takes the place of the ^2^13 in 7^2^13. Default is [["", "^"], ["", "^"], null]; if rootChars[2] is null, then it's set to ["^(base)^", ""].</li>
                    <li>inverseChars ( [[string, string], [string, string], [string, string] | null] | null) An equivalent of rootChars used for a root of negative iterations. Default is [["(", ")"], ["(", ")"], null]. If this is set to null instead of a pair of strings, negative iterations just show negative iterations of rootChars[2], such as ^2^-1.</li>
                    <li>superexpAfter ( boolean ) This is true by default; if it's true, a ^b^n expression comes after the number instead of before.</li>
                    <li>layerChars ( [string, string] ) A pair of strings that represent an additional layer: the first string is placed before the number, the second is placed afterwards. Default is ["", "^b^h"], where b is layerBase and h is height.</li>
                    <li>layerAfter ( boolean ) This is false by default; if it's true, the layerChars come after the number instead of before.</li>
                    <li>heightShown ( number ) This is -1 by default. If this is 0, the height is not shown. If this is positive, the height is shown at the beginning of the expression. If this is negative, the height is shown at the end of the expression. The height is not shown once the root is made into a ^b^n expression unless the absolute value of this parameter is above 1.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. DefaultNotation is the default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the n in an (^b^n) expression is itself notated with. Is the same as innerNotation by default.</li>
                    <li>heightInnerNotation ( Notation ) The notation that the base within the expression, if included, is itself notated with. Is the same as innerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>SuperRootNotation</h2>
                <p class="start_hide">Abbreviates numbers in terms of their super-root; this is the square super-root by default, so 256 is 42 and 46,656 is 62.</p>
                <ul class="param_list start_hide">
                    <li>height ( number ) The height of the super-root. Default is 2. This notation does not work with a super-root height less than 1.</li>
                    <li>iterations ( number ) The amount of super-root iterations: 1 is regular Super-Root notation, 2 means the super-root is taken twice, and so on. This can be negative.</li>
                    <li>rootChars ( [[string, string], [string, string], [string, string]] ) An array of three pairs of strings that are used as the characters to indicate super-root notation. In each pair, the first entry goes before the number, the second entry goes after the number. rootChars[0] takes the place of the  in "72", rootChars[1] takes the place of the second  in "(82)2" (rootChars[0] is for the innermost root, rootChars[1] is for the outer ones), and rootChars[2] takes the place of the (^) in 6(^7)2. Default is [["", ""], ["(", ")"], ["(^", ")"]].</li>
                    <li>inverseChars ( [[string, string], [string, string], [string, string]] ) An equivalent of rootChars used for a super-root of negative iterations. Default is [["sroot(", ")"], ["sroot(", ")"], ["(sroot^", ")"]]. If this is set to null instead of a pair of strings, negative iterations just show negative iterations of rootChars[2], such as (^-1).</li>
                    <li>superexpAfter ( boolean ) This is true by default; if it's true, an (^n) expression comes after the number instead of before.</li>
                    <li>heightShown ( number ) This is 0 by default. If this is 0, the height is not shown. If this is positive, the height is shown at the beginning of the expression. If this is negative, the height is shown at the end of the expression.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. DefaultNotation is the default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the number in an (^n) expression is itself notated with. Is the same as innerNotation by default.</li>
                    <li>baseInnerNotation ( Notation ) The notation that the base within the expression, if included, is itself notated with. Is the same as innerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>IncreasingSuperRootNotation</h2>
                <p class="start_hide">A variant of super-root notation that uses a different super-root height depending on how large the number is.</p>
                <ul class="param_list start_hide">
                    <li>maxnum ( Decimal ) Only numbers below this value are allowed to show up on their own - anything higher and the height increases. Default is 65536.</li>
                    <li>minHeight ( number ) The minimum super-root height. Default is 2.</li>
                    <li>max_in_a_row ( number ) If there are more super-root iterations than this, then the b's are made into a (b^n) expression. Default is 5.</li>
                    <li>engineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed height values: if it's three then the height will always be a multiple of 3. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted height values are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0).</li>
                    <li>rootChars ( [[string, string], [string, string], [string, string]] ) An array of three pairs of strings that are used as the characters to indicate super-root notation. In each pair, the first entry goes before the number, the second entry goes after the number. rootChars[0] takes the place of the  in "72", rootChars[1] takes the place of the second  in "(82)2" (rootChars[0] is for the innermost root, rootChars[1] is for the outer ones), and rootChars[2] takes the place of the (^) in 6(^7)2. Default is [["", ""], ["(", ")"], ["(^", ")"]].</li>
                    <li>inverseChars ( [[string, string], [string, string], [string, string]] ) An equivalent of rootChars used for a super-root of negative iterations. Default is [["sroot(", ")"], ["sroot(", ")"], ["(sroot^", ")"]]. If this is set to null instead of a pair of strings, negative iterations just show negative iterations of rootChars[2], such as (^-1).</li>
                    <li>superexpAfter ( boolean ) This is true by default; if it's true, an (^n) expression comes after the number instead of before.</li>
                    <li>heightShown ( number ) This is 0 by default. If this is 0, the height is not shown. If this is positive, the height is shown at the beginning of the expression. If this is negative, the height is shown at the end of the expression.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. DefaultNotation is the default.</li>
                    <li>superexponentInnerNotation ( Notation ) The notation that the number in an (^n) expression is itself notated with. Is the same as innerNotation by default.</li>
                    <li>baseInnerNotation ( Notation ) The notation that the base within the expression, if included, is itself notated with. Is the same as innerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>MultiSuperRootNotation</h2>
                <p class="start_hide">A variant of super-root notation that uses a different amount of super-root iterations depending on how large the number is.</p>
                <ul class="param_list start_hide">
                    <li>height ( number ) The height of the super-root. Default is 2. This notation does not work with a super-root height less than 1.</li>
                    <li>maxnum ( Decimal ) Only numbers below this value are allowed to show up on their own - anything higher and the amount of iterations increases. Default is 1e10.</li>
                    <li>max_in_a_row ( number ) If there are more super-root iterations than this, then the b's are made into a (b^n) expression. Default is 5.</li>
                    <li>minIterations ( number ) The minimum amount of super-root iterations. Default is 1.</li>
                    <li>engineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed iteration amounts: if it's three then the amount of iterations will always be a multiple of 3. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted iteration amounts are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0).</li>
                    <li>rootChars ( [[string, string], [string, string], [string, string]] ) An array of three pairs of strings that are used as the characters to indicate super-root notation. In each pair, the first entry goes before the number, the second entry goes after the number. rootChars[0] takes the place of the  in "72", rootChars[1] takes the place of the second  in "(82)2" (rootChars[0] is for the innermost root, rootChars[1] is for the outer ones), and rootChars[2] takes the place of the (^) in 6(^7)2. Default is [["", ""], ["(", ")"], ["(^", ")"]].</li>
                    <li>inverseChars ( [[string, string], [string, string], [string, string]] ) An equivalent of rootChars used for a super-root of negative iterations. Default is [["sroot(", ")"], ["sroot(", ")"], ["(sroot^", ")"]]. If this is set to null instead of a pair of strings, negative iterations just show negative iterations of rootChars[2], such as (^-1).</li>
                    <li>heightShown ( number ) This is 0 by default. If this is 0, the height is not shown. If this is positive, the height is shown at the beginning of the expression. If this is negative, the height is shown at the end of the expression.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. DefaultNotation is the default.</li>
                    <li>baseInnerNotation ( Notation ) The notation that the base within the expression, if included, is itself notated with. Is the same as innerNotation by default.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>PrimeNotation</h2>
                <p class="start_hide">
                    Writes numbers as their prime factorization: for example, writes 6 as 2 * 3, and writes 60 as 2^2 * 3 * 5.
                    For larger numbers, approximates them as a square root, then a cube root, then a fourth root, and so on, then as a power tower, and then as a tetration of some number to a whole height.
                    Supports non-whole numbers by approximating them as fractions.
                </p>
                <ul class="param_list start_hide">
                    <li>maxPrime ( number ) Only primes up to this value are checked for. Default is 10000. For example, if maxPrime is 5, then 231 would be written as 3 * 77 because 3 would be checked for but 7 and 11 would not be checked for (and so it wouldn't figure out that 77 is composite).</li>
                    <li>max_tower_height ( number ) If the power tower would be taller than this many layers, switches to tetrational format. Default is 5.</li>
                    <li>fractionPrecision ( number ) The precision with which non-whole numbers are approximated as fractions. If this is positive, the approximation will be within 'precision' of the true value. If this is negative, the approximation will be within 'value'/abs('precision') of the true value. In other words, a positive precision is absolute, a negative precision is proportional. Default is -1e-6.</li>
                    <li>numLimit ( number ) Only numbers below this point can stand on their own; anything higher and exponents are introduced. Default is maxPrime^2, as that's when inaccurate prime factorizations (where a supposed large prime actually has two large prime factors) can start showing up.</li>
                    <li>powerBase ( number ) If the power tower has more than two layers, all layers except the top two are set to this value. Default is maxPrime.</li>
                    <li>minimum ( number ) Numbers below this value are written in terms of their reciprocal. Default is 1 / maxPrime.</li>
                    <li>multiplicationString ( string ) The string placed between two prime factors. Default is " * ".</li>
                    <li>powerString ( [string, string] ) When a prime factor has an exponent, such as 3^2, this pair of strings controls what shows up between the base and the exponent: powerString[0] goes before the exponent, powerString[1] goes after the exponent. Default is ["^", ""].</li>
                    <li>powerBefore ( boolean ) If this is true, exponents on prime factors go before those primes instead of after. Default is false.</li>
                    <li>expChars ( [[string, string, string], [string, string, string]] ) An array containing two arrays, each of which contains three strings. In a power tower, expChars[0][0] goes before the tower, expChars[0][1] goes between each entry, and expChars[0][2] goes at the end of the tower. expChars[1] is like expChars[0], but for tetration instead of exponentiation. Default is [["(", ")^(", ")"], ["(", ")^^(", ")"]].</li>
                    <li>baseInnerNotation ( Notation ) The notation that the prime factors are themselves written in. DefaultNotation is the default.</li>
                    <li>powerInnerNotation ( Notation | null ) The notation that the exponents on the prime factors are written in. Is the same as baseInnerNotation by default. If this is null, then the exponents are themselves written in Prime notation.</li>
                    <li>recipString ( [string, string] | null ) When a number is written in terms of its reciprocal, recipString[0] goes before that reciprocal, recipString[1] goes afterwards. Default is null, which means recipString is set to ["(", ")" + powerString[0] + -1 + powerString[1]], where that -1 is however powerInnerNotation writes -1.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>PsiDashNotation</h2>
                <p class="start_hide">
                    Uses PsiCubed2's "lexiographic ordering" as described <a href="https://googology.fandom.com/wiki/User_blog:PsiCubed2/An_intuitive_lexicographic_ordering_of_numbers_up_to_P10_(%CF%89%5E%CF%89-level).">here</a>.
                    In summary, this notation starts with exponential expressions with E, then tetrational with F, then pentational with G, then (though this usually doesn't come up) hexational with H, but after the first entry (which represents the logarithm/super-logarithm/penta-logarithm) there are entries after dashes that each add accuracy to the approximation.
                    For example, in an E4-x expression, that x is the digits of the mantissa in n*10^4, and in an F8-x expression, that x is whatever's at the top of the power tower of 8 tens that represents the given value.
                    This notation obeys the rule that chopping off characters from the end always produces less accurate approximations, which means each digit has more precedence than all the digits afterwards:
                    for example, anything of the form F2-45-42..., no matter what comes after that 2, is greater than anything of the form F2-45-41...
                </p>
                <ul class="param_list start_hide">
                    <li>maxEntries ( number | number[] ) In its complete form, this is an array of four numbers: the first determines the maximum amount of dash entries for E-level numbers, the second is for F-level numbers, the third is for G-level numbers, and the fourth is for H-level numbers. If a single number is given instead of an array, all three values are set to that same number. If less than four elements are provided, the remaining elements are set to be equal to the last provided element. Default is [2, 4, 6, 8].</li>
                    <li>maxPrecision ( number ) The highest amount of digits that a dash entry can show. Default is 10.</li>
                    <li>base ( number | string[] ) This parameter, which can be either a number or an array of strings, controls the base this notation works in. If the base is a number, the default set of digits for that base is used: 0 through 9, then A through Z, then a through z, then + and /. This notation will throw an error if base is a number above 64, as only 64 default digits are chosen. If base is an array of strings, then those strings are taken as the digits of the base (the number of the base is base.length in this case); bases above 64 are allowed if you provide an array with more than 64 strings. Default is 10.</li>
                    <li>dashString ( string ) The string placed between each dash entry. Default is "-".</li>
                    <li>letters ( [string, string, string, string] ) The three letters used for exponential, tetrational, pentational, and hexational expressions respectively. Default is ["E", "F", "G", "H"].</li>
                    <li>recipString ( [string, string] | null ) When a number is written in terms of its reciprocal, recipString[0] goes before that reciprocal, recipString[1] goes afterwards. Default is null, which means recipString is set to ["1 / ", ""], where that 1 is however 1 is written in the base being used.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>PrestigeLayerNotation</h2>
                <p class="start_hide">
                    Writes numbers based on a system of infinite layers of prestige, where each layer requires a certain amount of the previous layer and is gained at some root of the previous layer.
                    For example, if root is 3 and requirement is 1e12, then it takes 1e12 of one layer's currency to get 1 of the next layer's currency, and multiplying the amount of one layer by X multiplies the amount of the next layer by X^(1/3).
                </p>
                <ul class="param_list start_hide">
                    <li>root ( Decimal ! ) Each layer's gain is this root of the previous layer's gain.</li>
                    <li>requirement ( Decimal ! ) 1 of layer X + 1 requires this much of layer X.</li>
                    <li>
                        recursive ( boolean ) If this is true, then once the layer number is itself larger than the original requirement, it will start being written in this notation itself. After a few layers of nesting, this switches to showing the amount of nestings, i.e. the "hyperlayer", along with the "payload" that's nested that many times. Default is false.
                        <span style="color:#ff5555">WARNING: When recursive is true, this notation is significantly laggy. Maybe don't turn this setting to true if you're using this for an incremental game...</span>
                    </li>
                    <li>
                        rampings ( [Decimal, Decimal, Decimal][] ) Each entry of this array consists of three Decimals: the first is the layer where that ramping interval starts, the second is the amount the root is ramping by, and the third is the amount the requirement is ramping by.
                        "Ramping" means that on each layer, the root is multiplied by its ramping amount, and the requirement is raised to the power of its ramping amount. For example, if root is 3, requirement is 1e12, and the first entry of ramping is [4, 3, 2],
                        then on the 4th layer the ramping begins, so on the 5th layer root becomes 9 and requirement becomes 1e24, on the 6th layer root becomes 27 and requirement becomes 1e48, on the 7th layer root becomes 81 and requirement becomes 1e96, and so on.
                        Default is [], which is effectively the same as [[0, 1, 1]], i.e. no ramping occurs.
                    </li>
                    <li>layerChars ( [string, string] ) A pair of strings. layerChars[0] is placed before the layer number, layerChars[1] is placed after the layer number. Default is ["[", "] "].</li>
                    <li>layerBefore ( boolean ) If this parameter is true, the layer comes before the amount of that layer instead of after. Default is true.</li>
                    <li>showLayerZero ( boolean ) If this parameter is false, then if the layer is zero, the number just uses amountInnerNotation and doesn't show the layer at all, but the layer is shown even when it's zero if this parameter is true. Default is true.</li>
                    <li>amountInnerNotation ( Notation ) The notation that the amount of the current layer is written with. DefaultNotation is the default.</li>
                    <li>layerInnerNotation ( Notation ) The notation that the layer number is written with. DefaultNotation is the default.</li>
                    <li>recipString ( [string, string] | null ) When a number is written in terms of its reciprocal, recipString[0] goes before that reciprocal, recipString[1] goes afterwards. Default is null, which means recipString is set to ["1 / ", ""], where that 1 is however 1 is written in amountInnerNotation.</li>
                    <li>maxNesting ( number ) The maximum amount of nestings of the layer before switching to hyperlayer format. This parameter does nothing if recursive is false. Default is 3.</li>
                    <li>
                        recursiveChars ( [[string, string], [string, string], [string, string]] ) An array of three pairs of strings that are used for recursive layers: recursiveChars[0][0] goes before the layer number once said layer number is itself notated in this notation, recursiveChars[0][1] goes after the layer number in that scenario.
                        recursiveChars[1] acts like layerChars, but for the hyperlayer number instead of the layer number, and likewise recursiveChars[2] acts like recursiveChars[0] but for the hyperlayer number.  This parameter does nothing if recursive is false. Default is [["[", "]"], ["{", "} "], ["{", "}"]].
                    </li>
                    <li>hyperlayerBefore ( boolean ) If this parameter is true, the hyperlayer comes before the payload instead of after. This parameter does nothing if recursive is false. Default is true.</li>
                    <li>hypermantissaPower ( number ) Normally, the payload in hyperlayer format is bounded by 1 and requirement, which corresponds to the default hypermantissaPower of 0. If hypermantissaPower is 1, the bounds are requirement and divisorAtLayer(requirement), if hypermantissaPower is 2 then the bounds are divisorAtLayer(requirement) and divisorAtLayer(divisorAtLayer(requirement)), and so on. For example, with a requirement of 1e12, a number normally represented as "{10} 100" would become "{9} [1] 100" with 1 hypermantissaPower and "{8} [[1] 100]" with 2 hypermantissaPower.</li>
                </ul>
                <p class="start_hide">This notation also has some public methods:</p>
                <ul class="param_list start_hide">
                    <li>
                        <span class="param_function">getLayer(value, rounded) : Decimal --- Given a certain amount of the layer 0 currency, returns the layer you'd be on.</span>
                    </li>
                    <ul>
                        <li>value ( Decimal ! ) The amount of the layer 0 currency you have.</li>
                        <li>rounded ( boolean ) Ensures that the given layer is a whole number. Default is true.</li>
                    </ul>
                    <li>
                        <span class="param_function">layerAndCurrency(value) : [Decimal, Decimal] --- Given a certain amount of the layer 0 currency, returns the layer you'd be on and the amount of currency you'd have on that layer. The function returns an array of the form [currency, layer].</span>
                    </li>
                    <ul>
                        <li>value ( Decimal ! ) The amount of the layer 0 currency you have.</li>
                    </ul>
                    <li>
                        <span class="param_function">iteratedLayer(value, iterations) : Decimal --- Applies getLayer multiple times.</span>
                    </li>
                    <ul>
                        <li>value ( Decimal ! ) The amount of the layer 0 currency you have.</li>
                        <li>iterations ( number ! ) The amount of times getLayer is applied to the value.</li>
                    </ul>
                    <li>
                        <span class="param_function">getHyperlayer(value) : Decimal --- The Prestige Layer equivalent of slog: how many times can we apply getLayer to value before it gets down to 1?</span>
                    </li>
                    <ul>
                        <li>value ( Decimal ! ) The amount of the layer 0 currency you have.</li>
                    </ul>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>IncreasingOperatorNotation</h2>
                <p class="start_hide">
                    Writes numbers using increasingly powerful operators: first addition, then multiplication, then exponentiation with a fixed top (i.e. root-style exponentiation),
                    then exponentiation with a fixed bottom (logarithm-style), then tetration with a fixed top (super-root), then tetration with a fixed bottom (super-logarithm).
                    Once too many of one operator is used but before it gets high enough to switch to the next, it starts showing how many times that operator is applied.
                    Smaller numbers with the operators applied to them are themselves written in this notation, allowing for nesting parameters.
                </p>
                <ul class="param_list start_hide">
                    <li>bases ( Decimal | Decimal[] ) bases[0] is the number being added to for addition, bases[1] is the number being multiplied by for multiplication, bases[2] is the height of the exponentiation for roots, bases[3] is the base of the exponentiation for exponentiation, bases[4] is the height of the tetration for super-roots, and bases[5] is the base of the tetration for tetration. If less than 6 entries are provided, then the remaining entries are filled in with defaults: addition's default is 10, multiplication matches addition by default, root gets 2 by default, exponentiation matches multiplication by default, super-root matches root by default, and tetration matches exponentiation by default. If a single Decimal is provided instead of an array, that Decimal is taken as addition's base and the rest are filled in with defaults. The default value of this parameter is 10.</li>
                    <li>maximums ( Decimal[] ) An array of Decimals: each one is a forced maximum for one operator, such that if the number being formatted is equal to or above that maximum, it's forced to the next operator. maximums[0] is the default plain number (i.e. the maximum number that doesn't get any operators at all), maximums[1] is for addition, maximums[2] is for multiplication, maximums[3] is for roots, maximums[4] is for exponentiation, and maximums[5] is for super-roots (tetration doesn't get a maximum because there's no operator after it). If less than 6 entries are provided, the remaining ones are set to Infinity (there are other ways for an operator to max out, so this is fine). If the array is empty, then maximums[0] (this one shouldn't be infinite, as if it was the operators wouldn't be used at all) is set to bases[0]. The default value for this parameter has maximums[0] be 10 and the rest of the maximums be Infinity.</li>
                    <li>
                        operatorChars ( [[string, string], [string, string], [string, string], [string, string]][] ) An array of arrays of four pairs of strings (the outermost array's length is not fixed like the inner arrays' lengths are). In each of these inner arrays, each pair of strings determines what goes around a number to represent an operator. For example:
                        operatorChars[0][0] is the pair of strings used for the innermost addition for the addition operator, with operatorChars[0][0][0] going before the number being added to and operatorChars[0][0][1] going afterwards. operatorChars[0][1] is also for addition, but for additions after the first one (in case you want to add parentheses around inner ones but not the outermost one, for example). operatorChars[0][2] and [0][3] are for once nesting addition begins, with [0][2] going around the number being added to and [0][3] going around the amount of addition operators applied. operatorChars[1] does all the same things as operatorChars[0] but for multiplication instead of addition, operatorChars[2] is for root, operatorChars[3] is for exponentiation, operatorChars[4] is for super-root, and operatorChars[5] is for tetration.
                        Default is
                            <br>[
                            <br>[["10 + ", ""], ["10 + ", ""], [" + ", ""], ["10 * ", ""]],
                            <br>[["10 * ", ""], ["10 * ", ""], [" * ", ""], ["10^", ""]],
                            <br>[["", "^2"], ["(", ")^2"], ["", ""], ["^2^", ""]],
                            <br>[["10^", ""], ["10^", ""], [" ", ""], ["(10^)^", ""]],
                            <br>[["", "^^2"], ["(", ")^^2"], ["", ""], [" (^^2)^", ""]],
                            <br>[["10^^", ""], ["10^^", ""], [" ", ""], ["(10^^)^", ""]]
                            <br>]
                    </li>
                    <li>
                        thresholds ( [Decimal, Decimal | boolean, number, Decimal, number][] ) Again, each entry in the outer array corresponds to one of the six operators.
                        In the inner arrays, thresholds[n][0] is the value at which the number being added to/multiplied by/raised to a power/etc., the "argument", switches from being written in plainInnerNotation to being written within the Increasing Operator notation itself, and thresholds[n][3] is that notation switch threshold for the amount of times the operator is applied once the nesting form begins.
                        thresholds[n][1] is a forced maximum on the argument, i.e. if the argument is not less than this value then another instance of the operator is applied to get it back below the threshold. thresholds[n][2] is the highest amount of times an operator can be applied before it switches to nesting form,
                        and thresholds[n][4] is the highest amount of "nestings" (i.e. where the amount of times the operator is applied is itself written in this notation with this operator being applied) before forcefully switching to the next operator.
                        thresholds[n][1] can be a boolean instead of a Decimal: if it's false then it's set to the maximum argument of the PREVIOUS operator, and if it's true then it's set to the maximum value before nesting form begins of the previous operator (thresholds[0][1] has no previous operator to refer to, so if it's a boolean then it's set to maximums[0]).
                        Default is an array containing six entries that are all [10, true, 4, 10, 2].
                    </li>
                    <li>
                        rootBehavior ( null | [boolean, Decimal, Decimal | boolean] ) If this is null (which is the default), then roots behave like the other operators, applying multiple times then switching to nesting form. However, if this is not null, then roots aren't applied multiple times: instead, the degree of the root increases for larger numbers.
                        rootBehavior[1] is how much the root degree changes by each time it increases; this value is added to the degree is rootBehavior[0] is false, but it multiplies the degree if rootBehavior[0] is true. rootBehavior[2] is the maximum height of the root before nesting in the height; thresholds[2][2] is ignored if rootBehavior is not null, but thresholds[2][4] still applies.
                        rootBehavior[2] can be a boolean, which follows the same rules as thresholds[2][1] does as a boolean.
                    </li>
                    <li>superRootBehavior ( null | [boolean, Decimal, Decimal | boolean] ) Same as rootBehavior, but for super-roots instead. Default is null.</li>
                    <li>
                        roundings ( [DecimalSource | ((value : Decimal) => Decimal), DecimalSource | ((value : Decimal) => Decimal), DecimalSource | ((value : Decimal) => Decimal)][] ) For a given operator, if rounding[n][0] is not 0, then the argument is rounded to the nearest multiple of that value if we're not in nesting form yet. If roundings[n][0] is a function, then the argument is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of.
                        roundings[n][1] and roundings[n][2] are similar, but [n][1] is for the argument in nesting form and [n][2] is for the amount of times the operator is applied in nesting form. Default is an array consisting of six [0, 0, 0]s, i.e. no rounding occurs.
                    </li>
                    <li>
                        preAdditionFormats ( [Decimal, string, string, string, string, (value : Decimal) => boolean, Notation][] ) Well, that's certainly a confusing type for this parameter, isn't it? Let me explain.
                        This parameter is used to format numbers before the operator begins, for the sake of notations like Omega and Fours. When one of these formats is applied, the number is subtracted by a certain amount and displayed surrounded by some strings corresponding to that amount.
                        <br>Here's what each entry does:
                        <br>preAdditionFormats[n][0] is the value that that format begins being used at, which is also the amount the number is subtracted by.
                        <br>preAdditionFormats[n][1] and [n][2] go before and after the number respectively. preAdditionFormats[n][3] and [n][4] also go before and after the number respectively, on the inside of the gap between [n][1] and [n][2]. (in other words, the writing goes [n][1], [n][3], number, [n][4], [n][2]).
                        <br>The reason [n][3] and [n][4] exist is because of [n][5], a Decimal => boolean function. If this function returns true, then the number is shown, but if it returns false, the number isn't shown. [n][3] and [n][4] are only shown if the number is shown, but [n][1] and [n][2] are shown even if the number isn't.
                        <br>Finally, [n][6] is the notation that the number is formatted in within this expression.
                        <br>All of this means nothing by default, though, since the default for preAdditionFormats is [], i.e. there are no preAdditionFormats by default.
                    </li>
                    <li>nestingBefore ( boolean[] ) For each entry of this array (each entry corresponds to one of the six operators), if that entry is true, then when that operator switches to nesting form, the amount of times the operator is applied is written before the argument instead of after. Default is [true, true, false, true, false, true]. If less than six entries are provided, the remaining ones are set to their default values.</li>
                    <li>
                        parenthesize ( [[string, string, boolean], [string, string, boolean], [string, string, boolean]][] ) Each entry in the outer array corresponds to one of the six operators, so let's focus on what's inside each entry.
                        Each entry consists of three [string, string, boolean] arrays, used to add parentheses to the argument and application number of an operator.
                        parenthesize[n][0][0] goes before the argument, parenthesize[n][0][1] goes afterwards, and parenthesize[n][0][2] determines when the parentheses start showing up:
                        if it's false then the parentheses only appear once the argument starts being written with Increasing Operator notation itself, but if it's true then the parentheses are always there (If you don't want the parentheses at all, just set the two strings to empty strings).
                        parenthesize[n][0] is for the argument before nesting form activates, parenthesize[n][1] is for the argument in nesting form, and parenthesize[n][2] is for the amount of times the operator is applied in nesting form.
                    </li>
                    <li>
                        argumentShown ( [(value : Decimal) => boolean, (value : Decimal) => boolean, [string, string]?, [string, string]?][] ) This parameter allows you to set times when the argument is not shown. As usual, each entry of the outer array corresponds to one of the six operators.
                        In each inner array, argumentShown[n][0] and [n][1] are Decimal -> boolean functions; the argument is only shown if that function returns true. [n][0] is for before nesting form, [n][1] is for during nesting form.
                        If the argument is not shown before nesting form, then argumentShown[n][2] and [n][3] replace operatorChars[n][0] and [n][1] respectively (for nesting form, the part with the argument is simply omitted, meaning operatorChars[n][2] is not used but [n][3] is).
                    </li>
                    <li>plainInnerNotation ( Notation ) The notation that regular numbers, i.e. numbers below maximums[0], are written in. DefaultNotation is the default.</li>
                    <li>
                        innerNotations ( Notation | [Notation, Notation, Notation][] ) Each entry in the outer array corresponds to one of the six operators.
                        innerNotations[n][0] is the notation that the argument for that operator is written in before switching to nesting form, innerNotations[n][1] is the notation the argument is written in in nesting form, and innerNotations[n][2] is the notation the operator number is written in in nesting form. These notations only apply before the argument and operator number's notational thresholds are reached.
                        You can also just input a single notation here and it will be used everywhere. (I wanted to also allow inputting a single [Notation, Notation, Notation], but it seems TypeScript has no way of safely distinguishing arrays from arrays of arrays...), which is what's done by default:
                        the default value of this parameter is DefaultNotation.
                    </li>
                    <li>minnum ( Decimal ) Values smaller than this are written in terms of their reciprocal. The default is the reciprocal of maximums[0].</li>
                    <li>recipString ( [string, string] | null ) When a number is written in terms of its reciprocal, recipString[0] goes before that reciprocal, recipString[1] goes afterwards. Default is null, which means recipString is set to ["1 / ", ""], where that 1 is however 1 is written in plainInnerNotation.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>PolygonalNotation</h2>
                <p class="start_hide">
                    Abbreviates numbers in terms of polygonal numbers (triangular numbers by default, but the amount of sides can be changed). For example, 10 is the 4th triangular number, so it's written as 4.
                     represents the amount of times  is applied to 2, so 10 means (((...2))) with 10 's. Similarly,  represents the amount of times  is applied to 2, so 5 means (((((2))))).
                </p>
                <ul class="param_list start_hide">
                    <li>sides ( Decimal ) The amount of sides on the polygon in question. Default is 3, which means the triangular numbers are used. This parameter must be greater than 2.</li>
                    <li>
                        polyChars ( [[string, string], [string, string], [string, string], [string, string], [string, string], [string, string]] )
                        When the number under a single-polygon is below maxnum (so it's written as a plain number), polyChars[0][0] is placed before the number and polyChars[0][1] is placed after the number.
                        polyChars[1][0] and [1][1] are used instead when the number is itself written in this notation.
                        polyChars[2] and [3] serve the same purpose as [0] and [1] respectively but for double-polygons,
                        and polyChars[4] and [5] are for triple-polygons.
                        Default is [["", ""], ["(", ")"], ["", ""], ["(", ")"], ["", ""], ["(", ")"]].
                    </li>
                    <li>maxnum ( Decimal ) Only numbers smaller than this can appear on their own; any larger and another polygonal root is taken. Default is 26796, i.e. 5.</li>
                    <li>maxPolys ( number ) The largest amount of single polygons in a row - any larger and they're truncated into a double polygon string. Default is 5.</li>
                    <li>biPolyBase ( Decimal ) The number that the single-polygons are repeatedly applied to to calculate the double-polygon number. Default is 2.</li>
                    <li>maxBiPolys ( number ) The largest amount of double polygons in a row - any larger and they're truncated into a triple polygon string. Is the same as maxPolys by default.</li>
                    <li>triPolyBase ( Decimal ) The number that the double-polygons are repeatedly applied to to calculate the triple-polygon number. Default is 2.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. DefaultNotation is the default.</li>
                    <li>minnum ( Decimal ) Values smaller than this are written in terms of their reciprocal. Default is whatever number is written as 0.1, which with sides == 3 is 0.055.</li>
                    <li>recipString ( [string, string] | null ) When a number is written in terms of its reciprocal, recipString[0] goes before that reciprocal, recipString[1] goes afterwards. Default is null, which means recipString is set to ["1 / ", ""], where that 1 is however 1 is written in plainInnerNotation.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>DoubleFactorialsNotation</h2>
                <p class="start_hide">
                    A Myriad-like notation that abbreviates numbers in terms of powers of double factorials (as in 3!! = (3!)! = 720) and a coefficient. Numbers below 720 are just written as normal, then a factor of 3!! is introduced, so 1080 would be 1.5 * 3!!.
                    Above 720^2, powers of 3!! are written as, well, powers of 3!!, so 1,000,000 would be around 1.929 * 3!!^2. The highest double factorial is included first, so powers of 4!! start being included, then 5!!, and so on; for example, 10^^4 is written as 5!! * 6!!^2 * 7!!^9 * 8!!^7 * 9!!^4 * 10!!^4 * 11!!^7 * 12!!^2.
                    Once the double factorial number gets too high, the entire thing is wrapped in a single factorial, such as (12!!^5 * 13!!^7)!, then multiple factorials, then the number of factorials gets written out, eventually in this notation as well.
                </p>
                <ul class="param_list start_hide">
                    <li>minDF ( Decimal ) The lowest double factorial that gets written as a double factorial - numbers below that are just written as the coefficient. Default is 3, meaning 3!! (720) is the cutoff point for the coefficient.</li>
                    <li>maxDF ( Decimal ) The limit of double factorial numbers - once the double factorial would reach this point, the number gets wrapped in another single factorial. Default is 3628800, i.e. 10!.</li>
                    <li>reverseTerms ( boolean ) If this parameter is true, the double factorials are written in descending order instead of ascending order. Default is false.</li>
                    <li>maxTerms ( number ) Only the largest few terms (double factorials and the coefficient) are written - this parameter controls how many terms are written. Default is 8.</li>
                    <li>multiplicationSign ( string ) The string placed between each term. Default is " * ".</li>
                    <li>divisionSign ( string ) The string placed between each term for numbers below 1. Default is " / ".</li>
                    <li>
                        DFChars ( [[string, string], [string, string], [string, string]] ) These are the strings used to indicate double factorials. For each of the three pairs in this array, the first entry goes before the number in question, the second goes after.
                        DFChars[0][0] and [0][1] go before and after the double factorial number itself. When a double factorial is raised to a power, [1][0] and [1][1] then go around that double factorial string, while [2][0] and [2][1] go around the exponent. Default is [["", "!!"], ["", ""], ["^", ""]].
                    </li>
                    <li>powerBefore ( boolean ) If this is true, the exponent on a double factorial goes before the double factorial instead of after. Default is false.</li>
                    <li>
                        factorialChars ( [[string, string], [string, string], [string, string], [string, string]] ) These strings are used for larger numbers to indicate further factorials have been taken. For each of the four pairs in this array, the first entry goes before the number in question, the second goes after.
                        factorialChars[0][0] and [0][1] go around the rest of the expression to indicate a single factorial is taken, then once more factorials are taken, [1][0] and [1][1] are used for all factorials beyond the innermost one.
                        Once it switches to writing out the amount of factorials as a number, [2][0] and [2][1] go around the rest of the expression, [3][0] and [3][1] go around the factorial amount. Default is [["(", ")!"], ["", "!"], ["(", ")!"], ["(", ")"]].
                    </li>
                    <li>maxFactorials ( number ) The largest amount of factorials that will be written out in a row - any more than this and the amount of factorials starts being written as a number. Default is 5.</li>
                    <li>factorialBefore ( boolean ) If this is true, the amount of factorials for super large numbers is written before the rest of the expression instead of after. Default is false.</li>
                    <li>coefficientInnerNotation ( Notation ) The notation that the coefficient is written in. DefaultNotation is the default.</li>
                    <li>DFInnerNotation ( Notation ) The notation that the double factorial numbers are written in. Is the same as coefficientInnerNotation by default.</li>
                    <li>powerInnerNotation ( Notation ) The notation that the exponents on double factorials are written in. Is the same as coefficientInnerNotation by default.</li>
                    <li>factorialInnerNotation ( Notation | null ) The notation that the amount of factorials is written in - if this is null, then the amount of factorials is written in this notation itself. Default is null.</li>
                    <li>recipString ( [string, string] ) When a number is written in terms of its reciprocal, recipString[0] goes before that reciprocal, recipString[1] goes afterwards. Default is null, which means recipString is set to ["1 / (", ")"], where that "1 / " is actually the concatenation of (how coefficientInnerNotation formats 1) and divisionSign.</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>GridNotation</h2>
                <p class="start_hide">
                    Uses a grid of empty and filled squares to represent numbers. Each row is written in binary, where empty squares are 0s and filled squares are 1s.
                    The first row represents the number itself. The second row represents how many extra squares the first row should have before the last ones (the last ones are what's shown) - in other words, whatever number n is in the second row means the first row is multiplied by 2^n.
                    The third row shows the amount of extra squares that should be in the second row, and so on.
                    Negative numbers have an empty diamond in front of the first row, and such a diamond can also be in front of the second row (so the exponent of the 2^n is negative) for small numbers.
                    For tetrational numbers, there may even be a second plane: the second plane's number is the amount of extra rows that the first plane should have before the last ones (the last ones are what's shown).
                </p>
                <ul class="param_list start_hide">
                    <li>width ( number ) The amount of squares in each row. Default is 8.</li>
                    <li>height ( number ) The amount of rows in each plane. Default is 8.</li>
                    <li>digits ( string[] ) The digits used to represent the numbers. These digits determine what number base the grid works in; as the name implies, digits[n] is the digit for the number n. Default is ["", ""].</li>
                    <li>rowOpenings ( [string, string, string] ) Each row begins with rowOpenings[0] normally, but if either of the first two rows is negative, then non-negative rows begin with rowOpenings[1] and negative rows begin with rowOpenings[2]. Default is ["", " ", ""].</li>
                    <li>fullFirstRow ( boolean ) If this parameter is true, the first row is divided by 2^(width - 1) so it always uses all of its digits, allowing representations of non-whole numbers to not just collapse to their integer part. Default is false.</li>
                    <li>opening ( string ) This string goes before the grid. Default is a newline character.</li>
                    <li>separator ( string ) This string goes between each digit. Default is the empty string.</li>
                    <li>betweenRows ( string ) This string goes between each row. Default is a newline character.</li>
                    <li>betweenPlanes ( string ) This string goes between each plane. Default is two newline characters.</li>
                    <li>minimumSizes ( [number, number, number] ) Digits of 0 will be added to the end of each row to ensure every row has at least a width of minimumSizes[0]. Rows of 0s will be added to the end of each plane to ensure every plane has at least a height of minimumSizes[1]. Planes of 0s will be added to the end of the grid to ensure the grid has at least a depth of minimumSizes[2]. Default is [width, height, 1], i.e. each plane is expanded to its full size but no extra planes are added.</li>
                    <li>backwards ( [boolean, boolean, boolean] ) If backwards[0] is true, then the digits within each row go greatest-to-least instead of least-to-greatest. backwards[1] is similar but for the order of rows within each plane, and backwards[2] is for the order of planes. Default is [false, false, false].</li>
                </ul>
            </div>
            <div class="subchapter start_hide">
                <h2>PolynomialNotation</h2>
                <p class="start_hide">
                    Writes numbers in the form of a polynomial-ish expression, with x having a certain value. For example, if x is 10, then 346 is written as 3x^2 + 4x + 6.
                </p>
                <ul class="param_list start_hide">
                    <li>value ( Decimal ) The value of x. Default is 10.</li>
                    <li>formatExponents ( number ) If this parameter is positive, then exponents are also written as polynomials, so x^x, x^(3x + 2), x^x^4x, and so on can appear. If this parameter is negative, the exponents are only written as numbers. If this parameter is zero, the exponents are not written at all. Default is 1.</li>
                    <li>minimumTerm ( Decimal ) The lowest power of x that gets a term, which may have a non-whole coefficient to account for what would be terms below this one. Default is 0, i.e. the constant term.</li>
                    <li>
                        fractionInverse ( boolean ) This parameter controls how negative powers of x are handled.
                        If this parameter is true, then the powers of x continue below the constant term, so if x = 10, then 1.25 is written as 1 + 2x^-1 + 5x^-2.
                        If this parameter is false, then the negative powers of x use denominators instead of negative exponents, so if x = 10, then 1.25 is written as 1 + 2/x + 5/x^2.
                        Default is true.
                    </li>
                    <li>maxTerms ( number ) The highest amount of terms shown; terms after the first few are cut off. Default is 8.</li>
                    <li>variableStr ( string ) The string used to represent the variable. Default is "x".</li>
                    <li>maxMultiTerm ( Decimal ) Only values below this have multiple terms shown. Values above this only show a single term and a coefficient (which may be non-whole). Default is value^^3 or 3^30, whichever is larger.</li>
                    <li>maxSingleTerm ( Decimal ) Values above this are considered too big to show on their own, so they get an x^ placed before them and are written in terms of that exponent. Default is value^^5.</li>
                    <li>maxExps ( number ) The highest amount of x^'s that can be placed before the polynomial in a row; any more than this and they're abbreviated in (x^)^n form. Default is 5.</li>
                    <li>showZeroTerms ( number ) If this parameter is negative, terms with a coefficient of zero are skipped. If this parameter is zero, then terms with a coefficient of zero are shown as long as there's some term with a nonzero coefficient later on. If this parameter is positive, terms, even those with a coefficient of zero, continue to be shown until the maximum amount of terms is hit. Default is -1.</li>
                    <li>innerNotation ( Notation ) The notation that the numbers within the expression are themselves notated with. DefaultNotation is the default.</li>
                    <li>additionSign ( string ) This string is placed between each term. Default is " + ".</li>
                    <li>subtractionSign ( string ) This string is placed between each term for negative numbers. Default is " - ".</li>
                    <li>multiplicationSign ( string ) This string is placed between the coefficient and the variable term. Default is the empty string.</li>
                    <li>divisionSign ( string ) This string is placed between the coefficient and the variable term for terms below x^0 when inverseTerms is positive. Default is "/".</li>
                    <li>multiplicationBefore ( boolean ) If this parameter is true, the coefficient is placed before the variable instead of after. Default is true.</li>
                    <li>powerStrings ( [string, string] ) A pair of strings used to denote exponents on variables: powerStrings[0] goes before the exponent, powerStrings[1] goes after the exponent. Default is ["&lt;sup&gt;", "&lt;/sup&gt;"].</li>
                    <li>coefficientStrings ( [string, string] ) A pair of strings used to denote coefficients on variables: coefficientStrings[0] goes before the coefficient, coefficientStrings[1] goes after the coefficient. Default is ["", ""].</li>
                    <li>parenthesizePower ( number ) If this parameter is negative, parentheses are not placed around the exponent. If this parameter is zero, parentheses are placed around the exponent if it contains variables, but not if it's just a number. If this parameter is positive, parentheses are always placed around the exponent. Default is -1.</li>
                    <li>unitCoefficientShown ( [boolean, boolean] ) If unitCoefficientShown[0] is true, the coefficient is shown even if it's 1. unitCoefficientShown[1] does the same thing, but for when divisionSign is used instead of for multiplicationSign. Default is [false, true].</li>
                    <li>unitPowerShown ( boolean ) Normally, the exponent on x is not shown if it's 1, but it's shown even in that case if unitPowerShown is true. Default is false.</li>
                    <li>
                        expStrings ( [[string, string], [string, string], [string, string], [string, string]] ) An array of four pairs of strings that indicate exponentiation on large numbers. In each pair, expStrings[n][0] goes before the value in question, expStrings[n][1] goes after.
                        expStrings[0] replaces the x^() that directly surrounds the number when it's large enough to get x^'s before it. expStrings[1] concerns the rest of the x^'s - expStrings[0] is only for the innermost x^, expStrings[1] is for the rest.
                        expStrings[2] replaces the (x^)^n that indicates repeated exponentiation when that n is just a number, expStrings[3] does the same thing but for when that n contains variables.
                        Default is [["x^(", ")"], ["x^", ""], ["(x^)^", " "], ["(x^)^(", ") "]], where that x is replaced with whatever variableStr is.
                    </li>
                    <li>superexpBefore ( boolean ) If this value is true, the repeated exponentiation string stuff comes before the polynomial instead of afterwards. Default is true.</li>
                    <li>frontSubtractionSign ( string ) This string is placed at the beginning of the expression for negative numbers. Is the same as subtractionSign by default.</li>
                    <li>constantStrings ( [string, string] ) A pair of strings used to denote the constant term: coefficientStrings[0] goes before the constant term, coefficientStrings[1] goes after the constant term. Default is ["", ""].</li>
                    <li>precision ( Decimal ) The expression will stop once it gets to within this level of precision compared to the original value, to ensure that meaningless terms (like an x^2 term in an expression with an x^2,000) from floating point imprecision aren't included. Default is 1.2e-16.</li>
                    <li>minimumTermRounding ( DecimalSource | ((value : Decimal) => Decimal) ) If the expression includes the minimum term, the minimum term is rounded to the nearest multiple of this value. If this parameter is a function, then the minimum term is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                </ul>
            </div>
        </div>

        <div class="chapter" style="background-color:#938700;border:5px solid #ecd800;color:#fff36e;">
            <h2 class="part_title">Part 3: Extra Functions</h2>
            <p class="start_hide">
                Those of you who have already tried the <a href="../index.html">preset demonstration page</a> and read Part 1
                of this documentation may have noticed that the last box on that page, the one that gives a physical description
                of the number in question, wasn't listed among the presets. That's because that box isn't actually using a
                preset: it's using one of the extra functions provided by Eternal Notations that isn't a notation.
                Eternal Notations has many utility functions that it uses in the process of many notations, and I decided to
                make some of those functions public because they could be useful by themselves. The things listed in this box
                are all functions with parameters, so I'm not going to bother with the separate text color stuff in this part.
                Like the notation constructors, any argument that requires a <code>Decimal</code>
                will accept any <code>DecimalSource</code>, but if a function returns a <code>Decimal</code> then that's definitely a
                <code>Decimal</code>. For functions with only a few arguments I'll write them out in the parentheses next to the function,
                but if a function has too many arguments then I'm just going to put "...args" in those parentheses - either way,
                the arguments will still be listed below the function.
                Here is the list of Eternal Notations's extra available functions:
            </p>
            <div class="param_list start_hide">
                <ul>
                    <li>toDecimal(value) : Decimal --- For reasons unbeknownst to me, break_eternity's Decimal.fromValue did not always seem to work on values that are already Decimals, so this function is a version of Decimal.fromValue that does.
                    Unlike Decimal.fromValue, this function uses the linear approximation of tetration to convert strings that involve tetration.</li>
                    <ul>
                        <li>value ( DecimalSource ! ) The DecimalSource to be converted.</li>
                    </ul>
                    <li>multabs(value) : Decimal --- "Multiplicative absolute value". For numbers with absolute value less than 1, returns their reciprocal. Otherwise, returns the original value. (0 just returns 0)</li>
                    <ul>
                        <li>value ( Decimal ! ) The number to take the multiplicative absolute value of.</li>
                    </ul>
                    <li>round(value, rounding) : Decimal --- Rounds the given value to the nearest multiple of some number.</li>
                    <ul>
                        <li>value ( Decimal ) The value to be rounded.</li>
                        <li>
                            rounding ( DecimalSource | ((value : Decimal) => Decimal) ) If this parameter is a Decimal, then "value" is rounded to the nearest multiple of "rounding".
                            If this parameter is a Decimal -> Decimal function, then "value" is plugged into that function, and whatever that function returns is used as the "rounding" to round to the nearest multiple of.
                            The rounding is not performed at all if "rounding" is 0.
                        </li>
                    </ul>
                    <li>commasAndDecimals(value, placesAbove1, placesBelow1, commas, decimalChar, commaChar): string --- Takes a number and formats it with commas and decimals.</li>
                    <ul>
                        <li>value ( number ! ) The number to be formatted.</li>
                        <li>placesAbove1 ( number ) For numbers 1 or greater, this is the amount of decimal places shown. If this is negative, then the absolute value of this parameter is the amount of significant figures shown (though place values before the decimal point are never cut off). Default is -4.</li>
                        <li>placesBelow1 ( number ) For numbers less than 1, this is the amount of decimal places shown. If this is negative, then the absolute value of this parameter is the amount of significant figures shown (though place values before the decimal point are never cut off). Default is -4.</li>
                        <li>commas ( number ) The smallest value where commas are included. If this is negative, then commas are never included. Default is 0, which means commas are always included.</li>
                        <li>decimalChar ( string ) The string used as the decimal point. Default is ".".</li>
                        <li>commaChar ( string ) The string used as the comma. Default is ",".</li>
                    </ul>
                    <li>
                        BaseConvert(value, base, placesAbove1, placesBelow1, negaDigits, commasMin, showZeroes, reverseDigits, commaSpacing, commaChars, decimalChar, negativeChar, precision, specialDigits, concatenation) : string
                        --- Converts a given number into a different base.
                    </li>
                    <ul>
                        <li>value ( number ! ) The number to be converted.</li>
                        <li>base ( number | string[] ! ) This can be either a number or an array of strings. If the base is a number, the default set of digits for that base is used: 0 through 9, then A through Z, then a through z, then + and /. This notation will throw an error if base is a number above 64, as only 64 default digits are chosen. If base is an array of strings, then those strings are taken as the digits of the base (the number of the base is base.length in this case); bases above 64 are allowed if you provide an array with more than 64 strings.</li>
                        <li>placesAbove1 ( number ) The amount of decimal places shown for numbers above 1. If this is negative, then the absolute value of this parameter is the amount of significant figures shown (though place values before the decimal point are never cut off). This value must be set to zero if negaDigits is -1 or base, as bijective bases do not support non-whole numbers. Default is -4.</li>
                        <li>placesBelow1 ( number ) The amount of decimal places shown for numbers below 1. If this is negative, then the absolute value of this parameter is the amount of significant figures shown (though place values before the decimal point are never cut off). This value must be set to zero if negaDigits is -1 or base, as bijective bases do not support non-whole numbers. Default is -4.</li>
                        <li>negaDigits ( number ) How many of the digits are negative? Default is 0, which means the digits are from 0 to (base - 1). For example, if negaDigits is 1, the digits are from -1 to (base - 2). For odd bases, set this to (base - 1)/2 for the "balanced" version of that base. The maximum value of negaDigits is the base itself, and the minimum value is -1 (which results in the bijective version of the base); values outside this range will throw an error. You can't set negaDigits to anything other than 0 or -1 if base is given as a number (rather than an array of strings), since digits for negative numbers are not included in the default set of digits.</li>
                        <li>commasMin ( number ) The smallest value where commas are included. If this is negative, then commas are never included. Default is 0, though this is no different from any value under base^commaSpacing.</li>
                        <li>showZeroes ( number ) A positive, zero, or negative number; default is -1. If this is positive, all the decimal places up to (places) are shown, even if some of them are zeroes at the end. If this is zero, all the decimal places up to (places) are shown, even if some are zeroes at the end, but only if not all of the decimal places are zero. If this is negative, zeroes at the end of the decimal places are not shown. If this is negative infinity, all trailing zeroes are removed, even those before the decimal point.</li>
                        <li>reverseDigits ( boolean ) If this parameter is true, digits are written right-to-left instead of left-to-right. Default is false.</li>
                        <li>commaSpacing ( number ) How many digits are between each comma. Default is 3.</li>
                        <li>commaChars ( string[] ) What are the commas? If this array of strings has only one character, that character is used as the comma. If the array has multiple characters, the array is cycled through, so commaChars[0] is used for the first comma (the comma closest to the ones place), commaChars[1] is used for the second comma, and repeat, going back to commaChars[0] after the last entry. Default is [","].</li>
                        <li>decimalChar ( string ) The character used as the decimal point. Default is ".".</li>
                        <li>negativeChar ( string ) The character used as the negative sign. Default is "-". There is no negative sign if negaDigits is between 1 and (base - 2); if negaDigits equals (base - 1) or base, the negative sign is used for positive numbers instead of negative numbers.</li>
                        <li>precision ( number ) How many digits are actually calculated before the remaining ones are just set to 0; this parameter exists so the notation doesn't bother displaying meaningless digits beyond the limit of floating point precision. Default is however many digits (2^53 - 1) has in that base.</li>
                        <li>
                            specialDigits ( [(placeValue : number, fromStart? : number, outerValue? : number) => boolean, string[]][] ) An array of pairs where each pair contains a (number, number?, number?) -> boolean function and a string array; this parameter allows different place values to use different digits (though the numeric value of the base remains the same).
                            The function's arguments are the place value of the digit (the ones place is place value 0), the digit's distance from the leftmost digit, and the value being inputted, and the function returns true if this digit is to use that set of special digits instead of the normal ones; the string array is the set of special digits to be used.
                            Earlier entries in specialDigits take priority, reverting back to the digits from base if none of the special digits apply or if the one that does apply doesn't have enough entries to represent that digit.
                        </li>
                        <li>
                            concatenation ( null | [boolean, string, string, Notation?] ) This parameter may either be null or an array containing a boolean, then two strings, then optionally a Notation. If this parameter is not null, then when multiple of the same digit are adjacent, they'll be concatenated into a single digit with a number next to it to indicate the amount of that digit that was concatenated.
                            concatenation[1] and concatenation[2] are placed before and after the concatenation number. If concatenation[3] is undefined, the concatenation number is written in the alternate base itself, otherwise it's written in whatever notation is given. If concatenation[0] is true, then the concatenation number comes after the digit being concatenated, otherwise it comes before.
                            Default is null, i.e. no concatenation occurs.
                        </li>
                    </ul>
                    <li>
                        FactoradicConvert(value, digitList, placesAbove1, placesBelow1, commasMin, showZeroes, reverseDigits, commaSpacing, commaChars, decimalChar, negativeChar, precision, specialDigits, concatenation) : string
                        --- Converts a given number into the "factoradic base", where the place values are the factorial numbers, which means each digit can go one value higher than the previous.
                    </li>
                    <ul>
                        <li>value ( number ! ) The number to be converted.</li>
                        <li>digitList ( string[] ) An array of strings taken as the digits of the base. Default is the default 64 digits: 0-9, then A-Z, then a-z, then +, then /.</li>
                        <li>placesAbove1 ( number ) The amount of decimal places shown for numbers above 1. If this is negative, then the absolute value of this parameter is the amount of significant figures shown (though place values before the decimal point are never cut off). This value must be set to zero if negaDigits is -1 or base, as bijective bases do not support non-whole numbers. Default is -4.</li>
                        <li>placesBelow1 ( number ) The amount of decimal places shown for numbers below 1. If this is negative, then the absolute value of this parameter is the amount of significant figures shown (though place values before the decimal point are never cut off). This value must be set to zero if negaDigits is -1 or base, as bijective bases do not support non-whole numbers. Default is -4.</li>
                        <li>commasMin ( number ) The smallest value where commas are included. If this is negative, then commas are never included. Default is 0, though this is no different from any value under base^commaSpacing.</li>
                        <li>showZeroes ( number ) A positive, zero, or negative number; default is -1. If this is positive, all the decimal places up to (places) are shown, even if some of them are zeroes at the end. If this is zero, all the decimal places up to (places) are shown, even if some are zeroes at the end, but only if not all of the decimal places are zero. If this is negative, zeroes at the end of the decimal places are not shown. If this is negative infinity, all trailing zeroes are removed, even those before the decimal point.</li>
                        <li>reverseDigits ( boolean ) If this parameter is true, digits are written right-to-left instead of left-to-right. Default is false.</li>
                        <li>commaSpacing ( number ) How many digits are between each comma. Default is 3.</li>
                        <li>commaChars ( string[] ) What are the commas? If this array of strings has only one character, that character is used as the comma. If the array has multiple characters, the array is cycled through, so commaChars[0] is used for the first comma (the comma closest to the ones place), commaChars[1] is used for the second comma, and repeat, going back to commaChars[0] after the last entry. Default is [","].</li>
                        <li>decimalChar ( string ) The character used as the decimal point. Default is ".".</li>
                        <li>negativeChar ( string ) The character used as the negative sign. Default is "-". There is no negative sign if negaDigits is between 1 and (base - 2); if negaDigits equals (base - 1) or base, the negative sign is used for positive numbers instead of negative numbers.</li>
                        <li>precision ( number ) How many digits are actually calculated before the remaining ones are just set to 0; this parameter exists so the notation doesn't bother displaying meaningless digits beyond the limit of floating point precision. Default is however many digits (2^53 - 1) has in that base.</li>
                        <li>
                            specialDigits ( [(placeValue : number, fromStart? : number, outerValue? : number) => boolean, string[]][] ) An array of pairs where each pair contains a (number, number?, number?) -> boolean function and a string array; this parameter allows different place values to use different digits (though the numeric value of the base remains the same).
                            The function's arguments are the place value of the digit (the ones place is place value 0), the digit's distance from the leftmost digit, and the value being inputted, and the function returns true if this digit is to use that set of special digits instead of the normal ones; the string array is the set of special digits to be used.
                            Earlier entries in specialDigits take priority, reverting back to the digits from base if none of the special digits apply or if the one that does apply doesn't have enough entries to represent that digit.
                        </li>
                        <li>
                            concatenation ( null | [boolean, string, string, Notation?] ) This parameter may either be null or an array containing a boolean, then two strings, then optionally a Notation. If this parameter is not null, then when multiple of the same digit are adjacent, they'll be concatenated into a single digit with a number next to it to indicate the amount of that digit that was concatenated.
                            concatenation[1] and concatenation[2] are placed before and after the concatenation number. If concatenation[3] is undefined, the concatenation number is written in the alternate base itself, otherwise it's written in whatever notation is given. If concatenation[0] is true, then the concatenation number comes after the digit being concatenated, otherwise it comes before.
                            Default is null, i.e. no concatenation occurs.
                        </li>
                    </ul>
                    <li>
                        fractionApproximation(value, precision, returnForm, maxIterations, maxDenominator, strictMaxDenominator) : number[]
                        --- Approximates a number as a fraction using continued fractions, returning whatever the first continued fraction approximation of that number that's close enough to the true value is.
                    </li>
                    <ul>
                        <li>value ( number ! ) The value to be approximated as a fraction.</li>
                        <li>precision ( number ! ) If this is positive, the approximation will be within 'precision' of the true value. If this is negative, the approximation will be within 'value'/abs('precision') of the true value. In other words, a positive precision is absolute, a negative precision is proportional. If precision is 0, it will be as exact as floating point numbers will allow.</li>
                        <li>returnForm ( number ! ) Controls what the returned array represents. 0 means "continued fraction", 1 means "numerator and denominator", 2 means "whole number, numerator, denominator", 3 means "whole number, numerator, and denominator, but change the fractional part for negatives to match how mixed numbers are actually written".</li>
                        <li>maxIterations ( number ) The process will end after this many iterations even if the desired precision has not been reached. Default is Infinity.</li>
                        <li>maxDenominator ( number ) If the approximation's denominator is above this, the approximation ends there. Default is Infinity, which means there is no maximum denominator.</li>
                        <li>strictMaxDenominator ( boolean ) If this parameter is true, then rather than the approximation stopping at the first approximation after the maximum denominator is exceeded, it stops at the last approximation before the maximum denominator is exceeded. Default is false.</li>
                        <li>maxNumerator ( number ) If the approximation's numerator is above this, the approximation ends there. Default is Infinity, which means there is no maximum numerator.</li>
                        <li>strictMaxNumerator ( boolean ) If this parameter is true, then rather than the approximation stopping at the first approximation after the maximum numerator is exceeded, it stops at the last approximation before the maximum numerator is exceeded (unless the approximation is already a whole number, in which case this parameter does not apply). Default is false.</li>
                    </ul>
                    <li>
                        fractionApproximationD(value, precision, returnForm, maxIterations, maxDenominator, strictMaxDenominator) : Decimal[]
                        --- Approximates a Decimal as a fraction using continued fractions, returning whatever the first continued fraction approximation of that number that's close enough to the true value is.
                    </li>
                    <ul>
                        <li>value ( Decimal ! ) The value to be approximated as a fraction.</li>
                        <li>precision ( Decimal ! ) If this is positive, the approximation will be within 'precision' of the true value. If this is negative, the approximation will be within 'value'/abs('precision') of the true value. In other words, a positive precision is absolute, a negative precision is proportional.</li>
                        <li>returnForm ( number ! ) Controls what the returned array represents. 0 means "continued fraction", 1 means "numerator and denominator", 2 means "whole number, numerator, denominator", 3 means "whole number, numerator, and denominator, but flip for negatives to match how mixed numbers are actually written".</li>
                        <li>maxIterations ( number ) The process will end after this many iterations even if the desired precision has not been reached. Default is Infinity.</li>
                        <li>maxDenominator ( Decimal ) If the approximation's denominator is above this, the approximation ends there. Default is Infinity, which means there is no maximum denominator.</li>
                        <li>strictMaxDenominator ( boolean ) If this parameter is true, then rather than the approximation stopping at the first approximation after the maximum denominator is exceeded, it stops at the last approximation before the maximum denominator is exceeded. Default is false.</li>
                        <li>maxNumerator ( Decimal ) If the approximation's numerator is above this, the approximation ends there. Default is Infinity, which means there is no maximum numerator.</li>
                        <li>strictMaxNumerator ( boolean ) If this parameter is true, then rather than the approximation stopping at the first approximation after the maximum numerator is exceeded, it stops at the last approximation before the maximum numerator is exceeded (unless the approximation is already a whole number, in which case this parameter does not apply). Default is false.</li>
                    </ul>
                    <li>primeFactorize(value, primes) : [number, number][] --- Turns a whole number into its prime factorization. Returns an array of pairs of numbers: in each pair is a prime and its exponent. For example, 60 would return [[2, 2], [3, 1], [5, 1]] since its prime factoration is 2^2 * 3^1 * 5^1. 1 returns an empty array, 0 returns [[0, 1]], negatives have [-1, 1] on the beginning of their array.</li>
                    <ul>
                        <li>value ( number ! ) The number to factorize. Must be an integer.</li>
                        <li>primes ( number | number[] ! ) If this is an array, that array is the list of prime factors to check for. If this is a number, all primes that are not greater than that number are checked.</li>
                    </ul>
                    <li>
                        primeFactorizeFraction(value, primes, precision, maxIterations, maxDenominator, strictMaxDenominator) : [number, number][]
                        --- Uses fractionApproximation to find an approximation of value as a fraction, then finds the prime factorization of that fraction using primeFactorize. For example, 40/63 would return [[2, 3], [3, -2], [5, 1], [7, -1]] because it's equal to 2^3 * 3^-2 * 5^1 * 7^-1.
                    </li>
                    <ul>
                        <li>value ( number ! ) The number to factorize.</li>
                        <li>primes ( number | number[] ! ) If this is an array, that array is the list of prime factors to check for. If this is a number, all primes that are not greater than that number are checked.</li>
                        <li>precision ( number ! ) If this is positive, the fraction approximation will be within 'precision' of the true value. If this is negative, the approximation will be within 'value'/abs('precision') of the true value. In other words, a positive precision is absolute, a negative precision is proportional.</li>
                        <li>maxIterations ( number ) The fraction approximating process will end after this many iterations even if the desired precision has not been reached. Default is Infinity.</li>
                        <li>maxDenominator ( number ) If the fraction approximation's denominator is above this, the fraction approximating ends there. Default is Infinity, which means there is no maximum denominator.</li>
                        <li>strictMaxDenominator ( boolean ) If this parameter is true, then rather than the fraction approximating stopping at the first approximation after the maximum denominator is exceeded, it stops at the last approximation before the maximum denominator is exceeded. Default is false.</li>
                        <li>maxNumerator ( number ) If the approximation's numerator is above this, the approximation ends there. Default is Infinity, which means there is no maximum numerator.</li>
                        <li>strictMaxNumerator ( boolean ) If this parameter is true, then rather than the approximation stopping at the first approximation after the maximum numerator is exceeded, it stops at the last approximation before the maximum numerator is exceeded (unless the approximation is already a whole number, in which case this parameter does not apply). Default is false.</li>
                    </ul>
                    <li>scientifify(value, base, rounding, mantissaPower, engineerings, expMultiplier): [Decimal, Decimal] --- Converts a Decimal into a list of two Decimals, [b, e], such that b * (base)^e equals the original value.</li>
                    <ul>
                        <li>value ( Decimal ! ) The value we want to turn into scientific notation.</li>
                        <li>base ( Decimal ) The base of the scientific notation we're using (default is 10)</li>
                        <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                        <li>mantissaPower ( Decimal ) Normally, the mantissa in scientific notation is bounded by 1 and the base, which corresponds to the default mantissaPower of 0. If mantissaPower is 1, the bounds are base and base^2, if mantissaPower is 2 then the bounds are base^2 and base^3, and so on. For example, 2.357e224 in base 10, which normally returns [2.357, 224], would become [23.57, 223] with 1 mantissaPower and [235.7, 222] with 2 mantissaPower.</li>
                        <li>engineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed exponent values: if it's three then the exponent will always be a multiple of 3, as in engineering notation. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted exponent values are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0).</li>
                        <li>expMultiplier ( Decimal ) In the returned pair, e is multiplied by this value. Default is 1.</li>
                    </ul>
                    <li>hyperscientifify(value, base, rounding, hypermantissaPower, engineerings, expMultiplier, hyperexpMultiplier): [Decimal, Decimal] --- Converts a Decimal into a list of two Decimals, [b, e], such that Decimal.iteratedexp(base, e, b, true) equals the original value.</li>
                    <ul>
                        <li>value ( Decimal ! ) The value we want to turn into hyperscientific notation.</li>
                        <li>base ( Decimal ) The base of the hyperscientific notation we're using (default is 10).</li>
                        <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                        <li>hypermantissaPower ( Decimal ) Normally, the mantissa in hyperscientific notation is bounded by 1 and the base, which corresponds to the default mantissaPower of 0. If mantissaPower is 1, the bounds are base and base^^2, if mantissaPower is 2 then the bounds are base^^2 and base^^3, and so on. For example, 1e100 in base 10, which normally returns [2, 2], would become [100, 1] with 1 mantissaPower and [1e100, 0] with 2 mantissaPower.</li>
                        <li>engineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed exponent values: if it's three then the exponent will always be a multiple of 3, as in engineering notation. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted exponent values are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0).</li>
                        <li>expMultiplier ( Decimal ) Each exponentiation in the iteratedexp, instead of just being base^value, is base^(value/expMultiplier), so that taking the logarithm to undo it would require multiplying by the expMultiplier after said logarithm. Default is 1.</li>
                        <li>hyperexpMultiplier ( Decimal ) In the returned pair, e is multiplied by this value. Default is 1.</li>
                    </ul>
                    <li>
                        hypersplit(value, base, maximums, originalMaximums, minnum, mantissaRounding, engineerings, hyperengineerings, pentaengineerings, expMult, hyperexpMult, pentaexpMult) : [Decimal, Decimal, Decimal, Decimal]
                        --- Splits a Decimal into an array of four decimals, [M, E, T, P], such that if b is the base, b^^b^^b^^...^^(b^b^b^b...^(m * b^e))) = the original Decimal, where there are T b^'s and P b^^'s.
                    </li>
                    <ul>
                        <li>value ( Decimal ! ) The Decimal inputted into the function.</li>
                        <li>base ( Decimal ) The base of the exponentiation, tetration, and pentation. Default is 10.</li>
                        <li>maximums ( Decimal[] ) The largest allowed values for each operator: anything equal to or above this rolls over to the next operator. maximums[0] is the mantissa limit, maximums[1] is the exponent limit, maximums[2] is the tetration limit. Default is [10, 10, 10]. Setting maximums[0] to 0 effectively disables the mantissa, setting maximums[1] to be equal to or less than expMult effectively disables the exponent, and setting maximums[2] to be equal to or less than hyperexpMult effectively disables the tetration.</li>
                        <li>originalMaximums ( Decimal[] ) These are the maximums that apply when the next operator is 0: for example, if maximums is [10, 10, 10] but originalMaximums is [100, 10, 10], then the mantissa can go up to 100 before exponents begin but once the exponent has begun increasing then the mantissa is limited to 10 (this applies even if tetration or pentation is above 0, as long as exponent is still 0). Is the same as maximums by default.</li>
                        <li>minnum ( Decimal ) Values above this and below maximums[0] will just return [value, 0, 0, 0] instead of doing any splitting; this prevents small-but-not-too-small values like 2 from forcing negative exponents. Default is 1. Set this value to a negative number to disable this functionality.</li>
                        <li>mantissaRounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                        <li>engineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed exponent values: if it's three then the exponent will always be a multiple of 3, as in engineering notation. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted exponent values are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0). Default is 1, which corresponds to regular scientific notation.</li>
                        <li>hyperengineerings ( Decimal | Decimal[] ) Same as engineerings, but for the tetration value instead.</li>
                        <li>pentaengineerings ( Decimal | Decimal[] ) Same as engineerings, but for the pentation value instead.</li>
                        <li>expMult ( Decimal ) Each exponentiation in the process is multiplied by this value. Default is 1.</li>
                        <li>hyperexpMult ( Decimal ) Each tetration in the process is multiplied by this value. Default is 1.</li>
                        <li>pentaexpMult ( Decimal ) The pentation value is multiplied by this value. Default is 1.</li>
                    </ul>
                    <li>iteratedfactorial(value, iterations) : Decimal --- Repeatedly takes the factorial of a Decimal.</li>
                    <ul>
                        <li>value ( Decimal ! ) The number we're taking factorials of.</li>
                        <li>iterations ( number ) The amount of times the factorial is taken. Uses an approximation for non-whole amounts of iterations. Default is 1.</li>
                    </ul>
                    <li>inverse_factorial(value, iterations) : Decimal --- The inverse of the factorial function: finds the number x such that x! = value. Equivalent to iteratedfactorial with a negative amount of iterations.</li>
                    <ul>
                        <li>value ( Decimal ! ) The value we're finding the inverse factorial of.</li>
                        <li>iterations ( number ) The amount of times the factorial is taken. Default is 1. For example, if iterations is 2, then it finds the number x such that x!! = value. Default is 1.</li>
                    </ul>
                    <li>factorial_slog(value, base) : Decimal --- This function is to iteratedfactorial and inverse_factorial as slog is to iteratedexp and iteratedlog: it returns the amount of times factorial must be applied to the base to return the given value.</li>
                    <ul>
                        <li>value ( Decimal ! ) The value we're finding the factorial_slog for.</li>
                        <li>base ( Decimal ) The number that the factorials are repeatedly applied to. The base must be greater than 2. Default is 3.</li>
                    </ul>
                    <li>factorial_scientifify(value, rounding, mantissaPower, engineerings): [Decimal, Decimal] --- Converts a Decimal into a list of two Decimals, [b, e], such that b * e! equals the original value.</li>
                    <ul>
                        <li>value ( Decimal ! ) The value to be converted into "factorial scientific notation".</li>
                        <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                        <li>mantissaPower ( Decimal ) Normally, the mantissa in factorial-scientific notation is bounded by 1 and (exponent + 1), which corresponds to the default mantissaPower of 0. If mantissaPower is 1, the bounds are (exponent + 1) and (exponent + 1)*(exponent + 2), if mantissaPower is 2 then the bounds are (exponent)*(exponent + 1) and (exponent)*(exponent + 1)*(exponent + 2), and so on. For example, 15!, which normally returns [1, 15], would become [15, 14] with 1 mantissaPower and [210, 13] with 2 mantissaPower.</li>
                        <li>engineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed factorial values: if it's three then the factorial will always be a multiple of 3. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted factorial values are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0).</li>
                    </ul>
                    <li>factorial_hyperscientifify(value, limit, rounding, engineerings): [Decimal, Decimal] --- Converts a Decimal into a list of two Decimals, [b, e], such that b!!!... with e !'s equals the original value.</li>
                    <ul>
                        <li>value ( Decimal ! ) The value to be converted into "factorial hyperscientific notation".</li>
                        <li>limit ( Decimal ) If the mantissa is equal to or above this value, the amount of factorials is increased by 1 to bring the mantissa back below this value. Default is 3.</li>
                        <li>rounding ( DecimalSource | ((value : Decimal) => Decimal) ) The mantissa is rounded to the nearest multiple of this value. If this parameter is a function, then the mantissa is plugged into the function, and whatever the function returns is used as the value to round to the nearest multiple of. The rounding is not performed at all if rounding is 0. Default is 0.</li>
                        <li>engineerings ( Decimal | Decimal[] ) Either a DecimalSource or an array of DecimalSources; default is 1. This parameter controls the allowed factorial amount values: if it's three then the factorial amount will always be a multiple of 3. If this is an array, then multiples of those values are added from greatest to least to get the allowed values: for example, if engineerings is [5, 2], then the permitted factorial amount values are 2, 4, 5, 7, 9, 10, 12, 14... and so on, i.e. multiples of 5 plus a multiple of 2 less than 5 (which may be 0).</li>
                    </ul>
                    <li>polygon(value, sides) : Decimal --- Returns the nth polygonal number of s sides; 3 sides is triangular numbers, 4 sides is perfect squares, etc. Grows quadratically.</li>
                    <ul>
                        <li>value ( Decimal ! ) The value we're taking the polygonal number of.</li>
                        <li>sides ( Decimal ! ) The amount of sides on the polygon.</li>
                    </ul>
                    <li>polygonRoot(value, sides) : Decimal --- One of the inverses of the polygon function. For polygon(n, s) = x, this function finds n given x and s. Grows at a square root rate (square root itself, of course, is the s = 4 case of polygonRoot).</li>
                    <ul>
                        <li>value ( Decimal ! ) The x in the above example.</li>
                        <li>sides ( Decimal ! ) The s in the above example.</li>
                    </ul>
                    <li>polygonLog(value, base) : Decimal --- One of the inverses of the polygon function. For polygon(n, s) = x, this function finds s given x and n. This is actually weaker than polygonRoot - polygonRoot has the strength of square root, but polygonLog has the strength of division.</li>
                    <ul>
                        <li>value ( Decimal ! ) The x in the above example.</li>
                        <li>base ( Decimal ! ) The n in the above example.</li>
                    </ul>
                    <li>biPolygon(value, sides, payload) : Decimal --- Iterated polygon: this function returns the result of applying polygon(x, s) to 'payload' (with the result placed in the x of the next application) 'value' times. Grows double-exponentially, using a linear approximation for fractional values (though this becomes irrelevant for values above 8 or so, as there's an approximating formula that holds for non-small values)</li>
                    <ul>
                        <li>value ( Decimal ! ) The amount of times the polygon function is applied.</li>
                        <li>sides ( Decimal ! ) The amount of sides on the polygon.</li>
                        <li>payload ( Decimal ) The number the polygon function is repeatedly applied to. Default is 2.</li>
                    </ul>
                    <li>iteratedPolygonRoot(payload, iterations, sides) : Decimal --- Performs polygonRoot on 'payload', 'iterations' times. Equivalent to biPolygon with a negative value.</li>
                    <ul>
                        <li>payload ( Decimal ! ) The number that's having the polygonal root repeatedly taken on.</li>
                        <li>iterations ( Decimal ! ) The amount of times the polygonal root is taken.</li>
                        <li>sides ( Decimal ! ) The amount of sides on the polygon.</li>
                    </ul>
                    <li>biPolygonRoot(value, sides, zeroValue) : Decimal --- Inverse function of biPolygon: for biPolygon(n, s, p) = x, this function finds n given x, s, and p. Grows double-logarithmically.</li>
                    <ul>
                        <li>value ( Decimal ! ) The x in the above example.</li>
                        <li>sides ( Decimal ! ) The s in the above example.</li>
                        <li>zeroValue ( Decimal ) The value that returns 0 for its root, a.k.a. the p in the above example. Default is 2.</li>
                    </ul>
                    <li>triPolygon(value, sides, base, payload) : Decimal --- Iterated biPolygon: this function returns the result of applying biPolygon(x, s, p) to 'base' (with the result placed in the x of the next application) 'value' times. Grows tetrationally (increasing value by 1 increases the super-logarithm by around 2). Uses a "linear" approximation for fractional values; I'll admit the approximation used is pretty arbitrary, because I didn't have any better ideas.</li>
                    <ul>
                        <li>value ( number ! ) The amount of times the biPolygon function is applied.</li>
                        <li>sides ( Decimal ! ) The amount of sides on the polygon.</li>
                        <li>base ( Decimal ) The payload used in each application of biPolygon. Default is 2.</li>
                        <li>payload ( Decimal ) The value that biPolygon is repeatedly applied to. Default is 2.</li>
                    </ul>
                    <li>iteratedBiPolygonRoot(payload, iterations, sides, zeroValue) : Decimal --- Performs biPolygonRoot on 'payload', 'iterations' times. Equivalent to triPolygon with a negative value.</li>
                    <ul>
                        <li>payload ( Decimal ! ) The number that's having the bipolygonal root repeatedly taken on.</li>
                        <li>iterations ( number ! ) The amount of times the bipolygonal root is taken.</li>
                        <li>sides ( Decimal ) The amount of sides on the polygon.</li>
                        <li>zeroValue ( Decimal ) The value that returns 0 for its root. Default is 2.</li>
                    </ul>
                    <li>triPolygonRoot(value, sides, base, zeroValue) : Decimal --- Inverse function of triPolygon: for triPolygon(n, s, b, p) = x, this function finds n given x, s, b, and p. Grows super-logarithmically.</li>
                    <ul>
                        <li>value ( Decimal ! ) The x in the above example.</li>
                        <li>sides ( Decimal ! ) The s in the above example.</li>
                        <li>base ( Decimal ) The b in the above example. Default is 2.</li>
                        <li>zeroValue ( Decimal ) The value that returns 0 for its root, a.k.a. the p in the above example. Default is 2.</li>
                    </ul>
                    <li>
                        physicalScale(value : DecimalSource) : string ---
                        This function gives a physical description of the Decimal it's given, to get across how large the number is.
                        For reasonably-sized numbers, this function expresses them in terms of how large of a volume you could fill with that many litres of water.
                        Once we get beyond the observable universe, it starts going to 4D versions of galaxies and universes, then 5D, and so on.
                        Then, for numbers where the amount of dimensions gets too large, it switches to considering an endlessly-replicating bacteria colony that doubles every second, and it tells you how long it would take for that exponential growth to reach your number.
                        Once that timespan becomes too long, it switches to considering the amount of possible permutations of the atoms in various objects.
                        Beyond that point, it switches between the atoms and bacteria scenarios, examining permutations, then permutations of the permutations, and so on.
                        Finally, for tetrational numbers, it gives up on representing the number itself and instead considers writing them as a power tower of 10s and how tall that power tower would be.
                        (Though this function behaves similarly to a Notation, it is not actually a Notation.)
                    </li>
                    <ul>
                        <li>value ( Decimal ! ) The value to give a description of.</li>
                    </ul>
                </ul>
            </div>
        </div>

        <div class="chapter" style="background-color:#c52700;border:5px solid #ff623b;color:#ff9479;">
            <h2 class="part_title">Credits</h2>
            <p class="start_hide">(In this section, "I", "me", etc. refer to MathCookie, the creator of Eternal Notations)</p>
            <p class="start_hide">
                Major credit to Patashu's <a href="https://github.com/Patashu/break_eternity.js">break_eternity.js</a>,
                the large number library that Eternal Notations is built on. Also, credit to <a href="https://github.com/antimatter-dimensions/notations">AD Notations</a>
                for inspiring Eternal Notations; the code for the Notation class was brought over from AD Notations. Aside from that code,
                though, pretty much all the rest of the code was written by me, so unlike AD Notations I don't have a bunch of
                coders to thank. Instead, this is where I'll note who came up with each of the notations that became Eternal Notations's
                presets. (Many of these, even if credited to others here, were extended to tetrational numbers by me. If one preset
                was inspired by another, then since the original is already listed under its creator, the spinoff will be listed under
                the person who came up with the change, not necessarily the creator of the original. Standard variants are listed
                based on who chose the prefixes for that variant; separate credit is given to the original list that all variants
                derived their prefixes from.)
            </p>
            <ul class="start_hide">
                <li>
                    The following presets are general math notations (so I don't have a developer to credit for them):
                    Default, Scientific, Engineering, Logarithm, Hyperscientific, Super Logarithm, Penta-Scientific,
                    Penta-Logarithm, the Natural Logarithms, Double Logarithm, the alternate bases, Roman Numerals,
                    SI, Binary SI, the Fraction and Mixed Number variants, Factorial, Factoradic, the roots and super-roots,
                    Prime, and the fractional bases.
                </li>
                <li>
                    The following presets were devised by me:
                    Standard, Long Scale, the Mixed Scientific versions of those two, Greek Alphabet, Emoji Alphabet, XYZ,
                    Element Letters, Septecoman, Hyper-SI, Letter Digits, Alphabet Digits, Eternity, Hearts, all Dominoes variants,
                    Factorial Amount, Factorial Scientific, Factorial Hyperscientific, Omega Layers (Ramped),
                    Increasing Operator and its variants, Triangular, Square, Double Factorials, Grid, Tetration Float,
                    Polynomial, Rational Function, and Powers of One (and the decision of what scales to use for physicalScale).
                </li>
                <li>
                    The following presets were devised by the creators of <a href="https://ivark.github.io/AntimatterDimensions/">Antimatter Dimensions</a> and AD Notations
                    (see <a href="https://github.com/antimatter-dimensions/notations/tree/master">AD Notations's GitHub page</a> for info on who implemented them there):
                    AD Standard, AD Long Scale, the Mixed Scientific versions of those two, Emoji, AD Roman, Infinity, Brackets,
                    Dots, and Blind (and the original inspiration for physicalScale).
                </li>
                <li>
                    The following presets were devised by <a href="https://aarextiaokhiao.github.io/">Aarex Tiaokhiao</a>:
                    Aarex Standard, Aarex Long Scale, the Mixed Scientific versions of those two, and Simplified Written.
                </li>
                <li>
                    The following presets were devised by <a href="https://veprogames.github.io/">VeproGames (formerly cook1ee)</a>:
                    AD Greek Letters, Omega Layers, Omega Layer Number, Omega, and Omega (Short).
                </li>
                <li>
                    The following presets were devised by others:
                    Power Tower (Robert Munafo's <a href="http://www.mrob.com/pub/perl/hypercalc.html">HyperCalc</a>),
                    the names of the Standard -illions that the prefixes were derived from (<a href="http://www.polytope.net/hedrondude/illion.htm">Jonathan Bowers</a>),
                    Alphabet (<a href="https://topcoggaming.com/">TopCog</a>),
                    Combined-D (Scratch user <a href="https://scratch.mit.edu/users/RobloxLover2015/">RobloxLover2015</a>),
                    Sandcastle Builder (<a href="https://castle.chirpingmustard.com/">Sandcastle Builder</a>),
                    Myriad (Donald Knuth's -yllion system), Double Binary Names/Prefixes (<a href="https://www.youtube.com/watch?v=rDDaEVcwIJM">the best way to count</a>),
                    Hypersplit (inspired by <a href="https://naruyoko.github.io/OmegaNum.js/index.html">OmegaNum.js</a>),
                    Hyper-E (<a href="https://sites.google.com/site/largenumbers/home/4-3/4-3-1-foray">Sbiis Saibian</a>),
                    Psi Letters and Psi Dash (<a href="https://googology.fandom.com/wiki/User_blog:PsiCubed2/My_Letter_Notation">PsiCubed2</a>),
                    and Fours (the four fours challenge).
                </li>
                <li>
                    I do not know the original source of the following presets:
                    Letters (Antimatter Dimensions popularized it, but incremental games had been using variations of this notation long before Antimatter Dimensions showed up).
                </li>
            </ul>
        </div>

        <script src="documentation.js"></script>
    </body>
</html>